// @generated by protobuf-ts 2.2.2
// @generated from protobuf file "api.proto" (syntax proto3)
// tslint:disable
import { void$ } from "./api_options";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// ==================== BASE PACKETS ====================

// The Home Assistant protocol is structured as a simple
// TCP socket with short binary messages encoded in the protocol buffers format
// First, a message in this protocol has a specific format:
//  * A zero byte.
//  * VarInt denoting the size of the message object. (type is not part of this)
//  * VarInt denoting the type of message.
//  * The message object encoded as a ProtoBuf message

// The connection is established in 4 steps:
//  * First, the client connects to the server and sends a "Hello Request" identifying itself
//  * The server responds with a "Hello Response" and selects the protocol version
//  * After receiving this message, the client attempts to authenticate itself using
//    the password and a "Connect Request"
//  * The server responds with a "Connect Response" and notifies of invalid password.
// If anything in this initial process fails, the connection must immediately closed
// by both sides and _no_ disconnection message is to be sent.

/**
 * Message sent at the beginning of each connection
 * Can only be sent by the client and only at the beginning of the connection
 *
 * @generated from protobuf message HelloRequest
 */
export interface HelloRequest {
    /**
     * Description of client (like User Agent)
     * For example "Home Assistant"
     * Not strictly necessary to send but nice for debugging
     * purposes.
     *
     * @generated from protobuf field: string client_info = 1;
     */
    clientInfo: string;
}
/**
 * Confirmation of successful connection request.
 * Can only be sent by the server and only at the beginning of the connection
 *
 * @generated from protobuf message HelloResponse
 */
export interface HelloResponse {
    /**
     * The version of the API to use. The _client_ (for example Home Assistant) needs to check
     * for compatibility and if necessary adopt to an older API.
     * Major is for breaking changes in the base protocol - a mismatch will lead to immediate disconnect_client_
     * Minor is for breaking changes in individual messages - a mismatch will lead to a warning message
     *
     * @generated from protobuf field: uint32 api_version_major = 1;
     */
    apiVersionMajor: number;
    /**
     * @generated from protobuf field: uint32 api_version_minor = 2;
     */
    apiVersionMinor: number;
    /**
     * A string identifying the server (ESP); like client info this may be empty
     * and only exists for debugging/logging purposes.
     * For example "ESPHome v1.10.0 on ESP8266"
     *
     * @generated from protobuf field: string server_info = 3;
     */
    serverInfo: string;
    /**
     * The name of the server (App.get_name())
     *
     * @generated from protobuf field: string name = 4;
     */
    name: string;
}
/**
 * Message sent at the beginning of each connection to authenticate the client
 * Can only be sent by the client and only at the beginning of the connection
 *
 * @generated from protobuf message ConnectRequest
 */
export interface ConnectRequest {
    /**
     * The password to log in with
     *
     * @generated from protobuf field: string password = 1;
     */
    password: string;
}
/**
 * Confirmation of successful connection. After this the connection is available for all traffic.
 * Can only be sent by the server and only at the beginning of the connection
 *
 * @generated from protobuf message ConnectResponse
 */
export interface ConnectResponse {
    /**
     * @generated from protobuf field: bool invalid_password = 1;
     */
    invalidPassword: boolean;
}
/**
 * Request to close the connection.
 * Can be sent by both the client and server
 *
 * @generated from protobuf message DisconnectRequest
 */
export interface DisconnectRequest {
}
/**
 * @generated from protobuf message DisconnectResponse
 */
export interface DisconnectResponse {
}
/**
 * @generated from protobuf message PingRequest
 */
export interface PingRequest {
}
/**
 * @generated from protobuf message PingResponse
 */
export interface PingResponse {
}
/**
 * @generated from protobuf message DeviceInfoRequest
 */
export interface DeviceInfoRequest {
}
/**
 * @generated from protobuf message DeviceInfoResponse
 */
export interface DeviceInfoResponse {
    /**
     * @generated from protobuf field: bool uses_password = 1;
     */
    usesPassword: boolean;
    /**
     * The name of the node, given by "App.set_name()"
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * The mac address of the device. For example "AC:BC:32:89:0E:A9"
     *
     * @generated from protobuf field: string mac_address = 3;
     */
    macAddress: string;
    /**
     * A string describing the ESPHome version. For example "1.10.0"
     *
     * @generated from protobuf field: string esphome_version = 4;
     */
    esphomeVersion: string;
    /**
     * A string describing the date of compilation, this is generated by the compiler
     * and therefore may not be in the same format all the time.
     * If the user isn't using ESPHome, this will also not be set.
     *
     * @generated from protobuf field: string compilation_time = 5;
     */
    compilationTime: string;
    /**
     * The model of the board. For example NodeMCU
     *
     * @generated from protobuf field: string model = 6;
     */
    model: string;
    /**
     * @generated from protobuf field: bool has_deep_sleep = 7;
     */
    hasDeepSleep: boolean;
    /**
     * The esphome project details if set
     *
     * @generated from protobuf field: string project_name = 8;
     */
    projectName: string;
    /**
     * @generated from protobuf field: string project_version = 9;
     */
    projectVersion: string;
    /**
     * @generated from protobuf field: uint32 webserver_port = 10;
     */
    webserverPort: number;
}
/**
 * @generated from protobuf message ListEntitiesRequest
 */
export interface ListEntitiesRequest {
}
/**
 * @generated from protobuf message ListEntitiesDoneResponse
 */
export interface ListEntitiesDoneResponse {
}
/**
 * @generated from protobuf message SubscribeStatesRequest
 */
export interface SubscribeStatesRequest {
}
/**
 * ==================== BINARY SENSOR ====================
 *
 * @generated from protobuf message ListEntitiesBinarySensorResponse
 */
export interface ListEntitiesBinarySensorResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string device_class = 5;
     */
    deviceClass: string;
    /**
     * @generated from protobuf field: bool is_status_binary_sensor = 6;
     */
    isStatusBinarySensor: boolean;
    /**
     * @generated from protobuf field: bool disabled_by_default = 7;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: string icon = 8;
     */
    icon: string;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 9;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message BinarySensorStateResponse
 */
export interface BinarySensorStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool state = 2;
     */
    state: boolean;
    /**
     * If the binary sensor does not have a valid state yet.
     * Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
     *
     * @generated from protobuf field: bool missing_state = 3;
     */
    missingState: boolean;
}
/**
 * ==================== COVER ====================
 *
 * @generated from protobuf message ListEntitiesCoverResponse
 */
export interface ListEntitiesCoverResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: bool assumed_state = 5;
     */
    assumedState: boolean;
    /**
     * @generated from protobuf field: bool supports_position = 6;
     */
    supportsPosition: boolean;
    /**
     * @generated from protobuf field: bool supports_tilt = 7;
     */
    supportsTilt: boolean;
    /**
     * @generated from protobuf field: string device_class = 8;
     */
    deviceClass: string;
    /**
     * @generated from protobuf field: bool disabled_by_default = 9;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: string icon = 10;
     */
    icon: string;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 11;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message CoverStateResponse
 */
export interface CoverStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * legacy: state has been removed in 1.13
     * clients/servers must still send/accept it until the next protocol change
     *
     * @generated from protobuf field: LegacyCoverState legacy_state = 2;
     */
    legacyState: LegacyCoverState;
    /**
     * @generated from protobuf field: float position = 3;
     */
    position: number;
    /**
     * @generated from protobuf field: float tilt = 4;
     */
    tilt: number;
    /**
     * @generated from protobuf field: CoverOperation current_operation = 5;
     */
    currentOperation: CoverOperation;
}
/**
 * @generated from protobuf message CoverCommandRequest
 */
export interface CoverCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * legacy: command has been removed in 1.13
     * clients/servers must still send/accept it until the next protocol change
     *
     * @generated from protobuf field: bool has_legacy_command = 2;
     */
    hasLegacyCommand: boolean;
    /**
     * @generated from protobuf field: LegacyCoverCommand legacy_command = 3;
     */
    legacyCommand: LegacyCoverCommand;
    /**
     * @generated from protobuf field: bool has_position = 4;
     */
    hasPosition: boolean;
    /**
     * @generated from protobuf field: float position = 5;
     */
    position: number;
    /**
     * @generated from protobuf field: bool has_tilt = 6;
     */
    hasTilt: boolean;
    /**
     * @generated from protobuf field: float tilt = 7;
     */
    tilt: number;
    /**
     * @generated from protobuf field: bool stop = 8;
     */
    stop: boolean;
}
/**
 * ==================== FAN ====================
 *
 * @generated from protobuf message ListEntitiesFanResponse
 */
export interface ListEntitiesFanResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: bool supports_oscillation = 5;
     */
    supportsOscillation: boolean;
    /**
     * @generated from protobuf field: bool supports_speed = 6;
     */
    supportsSpeed: boolean;
    /**
     * @generated from protobuf field: bool supports_direction = 7;
     */
    supportsDirection: boolean;
    /**
     * @generated from protobuf field: int32 supported_speed_count = 8;
     */
    supportedSpeedCount: number;
    /**
     * @generated from protobuf field: bool disabled_by_default = 9;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: string icon = 10;
     */
    icon: string;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 11;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message FanStateResponse
 */
export interface FanStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool state = 2;
     */
    state: boolean;
    /**
     * @generated from protobuf field: bool oscillating = 3;
     */
    oscillating: boolean;
    /**
     * @deprecated
     * @generated from protobuf field: FanSpeed speed = 4 [deprecated = true];
     */
    speed: FanSpeed;
    /**
     * @generated from protobuf field: FanDirection direction = 5;
     */
    direction: FanDirection;
    /**
     * @generated from protobuf field: int32 speed_level = 6;
     */
    speedLevel: number;
}
/**
 * @generated from protobuf message FanCommandRequest
 */
export interface FanCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool has_state = 2;
     */
    hasState: boolean;
    /**
     * @generated from protobuf field: bool state = 3;
     */
    state: boolean;
    /**
     * @deprecated
     * @generated from protobuf field: bool has_speed = 4 [deprecated = true];
     */
    hasSpeed: boolean;
    /**
     * @deprecated
     * @generated from protobuf field: FanSpeed speed = 5 [deprecated = true];
     */
    speed: FanSpeed;
    /**
     * @generated from protobuf field: bool has_oscillating = 6;
     */
    hasOscillating: boolean;
    /**
     * @generated from protobuf field: bool oscillating = 7;
     */
    oscillating: boolean;
    /**
     * @generated from protobuf field: bool has_direction = 8;
     */
    hasDirection: boolean;
    /**
     * @generated from protobuf field: FanDirection direction = 9;
     */
    direction: FanDirection;
    /**
     * @generated from protobuf field: bool has_speed_level = 10;
     */
    hasSpeedLevel: boolean;
    /**
     * @generated from protobuf field: int32 speed_level = 11;
     */
    speedLevel: number;
}
/**
 * @generated from protobuf message ListEntitiesLightResponse
 */
export interface ListEntitiesLightResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: repeated ColorMode supported_color_modes = 12;
     */
    supportedColorModes: ColorMode[];
    /**
     * next four supports_* are for legacy clients, newer clients should use color modes
     *
     * @deprecated
     * @generated from protobuf field: bool legacy_supports_brightness = 5 [deprecated = true];
     */
    legacySupportsBrightness: boolean;
    /**
     * @deprecated
     * @generated from protobuf field: bool legacy_supports_rgb = 6 [deprecated = true];
     */
    legacySupportsRgb: boolean;
    /**
     * @deprecated
     * @generated from protobuf field: bool legacy_supports_white_value = 7 [deprecated = true];
     */
    legacySupportsWhiteValue: boolean;
    /**
     * @deprecated
     * @generated from protobuf field: bool legacy_supports_color_temperature = 8 [deprecated = true];
     */
    legacySupportsColorTemperature: boolean;
    /**
     * @generated from protobuf field: float min_mireds = 9;
     */
    minMireds: number;
    /**
     * @generated from protobuf field: float max_mireds = 10;
     */
    maxMireds: number;
    /**
     * @generated from protobuf field: repeated string effects = 11;
     */
    effects: string[];
    /**
     * @generated from protobuf field: bool disabled_by_default = 13;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: string icon = 14;
     */
    icon: string;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 15;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message LightStateResponse
 */
export interface LightStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool state = 2;
     */
    state: boolean;
    /**
     * @generated from protobuf field: float brightness = 3;
     */
    brightness: number;
    /**
     * @generated from protobuf field: ColorMode color_mode = 11;
     */
    colorMode: ColorMode;
    /**
     * @generated from protobuf field: float color_brightness = 10;
     */
    colorBrightness: number;
    /**
     * @generated from protobuf field: float red = 4;
     */
    red: number;
    /**
     * @generated from protobuf field: float green = 5;
     */
    green: number;
    /**
     * @generated from protobuf field: float blue = 6;
     */
    blue: number;
    /**
     * @generated from protobuf field: float white = 7;
     */
    white: number;
    /**
     * @generated from protobuf field: float color_temperature = 8;
     */
    colorTemperature: number;
    /**
     * @generated from protobuf field: float cold_white = 12;
     */
    coldWhite: number;
    /**
     * @generated from protobuf field: float warm_white = 13;
     */
    warmWhite: number;
    /**
     * @generated from protobuf field: string effect = 9;
     */
    effect: string;
}
/**
 * @generated from protobuf message LightCommandRequest
 */
export interface LightCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool has_state = 2;
     */
    hasState: boolean;
    /**
     * @generated from protobuf field: bool state = 3;
     */
    state: boolean;
    /**
     * @generated from protobuf field: bool has_brightness = 4;
     */
    hasBrightness: boolean;
    /**
     * @generated from protobuf field: float brightness = 5;
     */
    brightness: number;
    /**
     * @generated from protobuf field: bool has_color_mode = 22;
     */
    hasColorMode: boolean;
    /**
     * @generated from protobuf field: ColorMode color_mode = 23;
     */
    colorMode: ColorMode;
    /**
     * @generated from protobuf field: bool has_color_brightness = 20;
     */
    hasColorBrightness: boolean;
    /**
     * @generated from protobuf field: float color_brightness = 21;
     */
    colorBrightness: number;
    /**
     * @generated from protobuf field: bool has_rgb = 6;
     */
    hasRgb: boolean;
    /**
     * @generated from protobuf field: float red = 7;
     */
    red: number;
    /**
     * @generated from protobuf field: float green = 8;
     */
    green: number;
    /**
     * @generated from protobuf field: float blue = 9;
     */
    blue: number;
    /**
     * @generated from protobuf field: bool has_white = 10;
     */
    hasWhite: boolean;
    /**
     * @generated from protobuf field: float white = 11;
     */
    white: number;
    /**
     * @generated from protobuf field: bool has_color_temperature = 12;
     */
    hasColorTemperature: boolean;
    /**
     * @generated from protobuf field: float color_temperature = 13;
     */
    colorTemperature: number;
    /**
     * @generated from protobuf field: bool has_cold_white = 24;
     */
    hasColdWhite: boolean;
    /**
     * @generated from protobuf field: float cold_white = 25;
     */
    coldWhite: number;
    /**
     * @generated from protobuf field: bool has_warm_white = 26;
     */
    hasWarmWhite: boolean;
    /**
     * @generated from protobuf field: float warm_white = 27;
     */
    warmWhite: number;
    /**
     * @generated from protobuf field: bool has_transition_length = 14;
     */
    hasTransitionLength: boolean;
    /**
     * @generated from protobuf field: uint32 transition_length = 15;
     */
    transitionLength: number;
    /**
     * @generated from protobuf field: bool has_flash_length = 16;
     */
    hasFlashLength: boolean;
    /**
     * @generated from protobuf field: uint32 flash_length = 17;
     */
    flashLength: number;
    /**
     * @generated from protobuf field: bool has_effect = 18;
     */
    hasEffect: boolean;
    /**
     * @generated from protobuf field: string effect = 19;
     */
    effect: string;
}
/**
 * @generated from protobuf message ListEntitiesSensorResponse
 */
export interface ListEntitiesSensorResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: string unit_of_measurement = 6;
     */
    unitOfMeasurement: string;
    /**
     * @generated from protobuf field: int32 accuracy_decimals = 7;
     */
    accuracyDecimals: number;
    /**
     * @generated from protobuf field: bool force_update = 8;
     */
    forceUpdate: boolean;
    /**
     * @generated from protobuf field: string device_class = 9;
     */
    deviceClass: string;
    /**
     * @generated from protobuf field: SensorStateClass state_class = 10;
     */
    stateClass: SensorStateClass;
    /**
     * Last reset type removed in 2021.9.0
     *
     * @generated from protobuf field: SensorLastResetType legacy_last_reset_type = 11;
     */
    legacyLastResetType: SensorLastResetType;
    /**
     * @generated from protobuf field: bool disabled_by_default = 12;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 13;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message SensorStateResponse
 */
export interface SensorStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: float state = 2;
     */
    state: number;
    /**
     * If the sensor does not have a valid state yet.
     * Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
     *
     * @generated from protobuf field: bool missing_state = 3;
     */
    missingState: boolean;
}
/**
 * ==================== SWITCH ====================
 *
 * @generated from protobuf message ListEntitiesSwitchResponse
 */
export interface ListEntitiesSwitchResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: bool assumed_state = 6;
     */
    assumedState: boolean;
    /**
     * @generated from protobuf field: bool disabled_by_default = 7;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 8;
     */
    entityCategory: EntityCategory;
    /**
     * @generated from protobuf field: string device_class = 9;
     */
    deviceClass: string;
}
/**
 * @generated from protobuf message SwitchStateResponse
 */
export interface SwitchStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool state = 2;
     */
    state: boolean;
}
/**
 * @generated from protobuf message SwitchCommandRequest
 */
export interface SwitchCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool state = 2;
     */
    state: boolean;
}
/**
 * ==================== TEXT SENSOR ====================
 *
 * @generated from protobuf message ListEntitiesTextSensorResponse
 */
export interface ListEntitiesTextSensorResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: bool disabled_by_default = 6;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 7;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message TextSensorStateResponse
 */
export interface TextSensorStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: string state = 2;
     */
    state: string;
    /**
     * If the text sensor does not have a valid state yet.
     * Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
     *
     * @generated from protobuf field: bool missing_state = 3;
     */
    missingState: boolean;
}
/**
 * @generated from protobuf message SubscribeLogsRequest
 */
export interface SubscribeLogsRequest {
    /**
     * @generated from protobuf field: LogLevel level = 1;
     */
    level: LogLevel;
    /**
     * @generated from protobuf field: bool dump_config = 2;
     */
    dumpConfig: boolean;
}
/**
 * @generated from protobuf message SubscribeLogsResponse
 */
export interface SubscribeLogsResponse {
    /**
     * @generated from protobuf field: LogLevel level = 1;
     */
    level: LogLevel;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
    /**
     * @generated from protobuf field: bool send_failed = 4;
     */
    sendFailed: boolean;
}
/**
 * ==================== HOMEASSISTANT.SERVICE ====================
 *
 * @generated from protobuf message SubscribeHomeassistantServicesRequest
 */
export interface SubscribeHomeassistantServicesRequest {
}
/**
 * @generated from protobuf message HomeassistantServiceMap
 */
export interface HomeassistantServiceMap {
    /**
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * @generated from protobuf message HomeassistantServiceResponse
 */
export interface HomeassistantServiceResponse {
    /**
     * @generated from protobuf field: string service = 1;
     */
    service: string;
    /**
     * @generated from protobuf field: repeated HomeassistantServiceMap data = 2;
     */
    data: HomeassistantServiceMap[];
    /**
     * @generated from protobuf field: repeated HomeassistantServiceMap data_template = 3;
     */
    dataTemplate: HomeassistantServiceMap[];
    /**
     * @generated from protobuf field: repeated HomeassistantServiceMap variables = 4;
     */
    variables: HomeassistantServiceMap[];
    /**
     * @generated from protobuf field: bool is_event = 5;
     */
    isEvent: boolean;
}
/**
 * ==================== IMPORT HOME ASSISTANT STATES ====================
 * 1. Client sends SubscribeHomeAssistantStatesRequest
 * 2. Server responds with zero or more SubscribeHomeAssistantStateResponse (async)
 * 3. Client sends HomeAssistantStateResponse for state changes.
 *
 * @generated from protobuf message SubscribeHomeAssistantStatesRequest
 */
export interface SubscribeHomeAssistantStatesRequest {
}
/**
 * @generated from protobuf message SubscribeHomeAssistantStateResponse
 */
export interface SubscribeHomeAssistantStateResponse {
    /**
     * @generated from protobuf field: string entity_id = 1;
     */
    entityId: string;
    /**
     * @generated from protobuf field: string attribute = 2;
     */
    attribute: string;
}
/**
 * @generated from protobuf message HomeAssistantStateResponse
 */
export interface HomeAssistantStateResponse {
    /**
     * @generated from protobuf field: string entity_id = 1;
     */
    entityId: string;
    /**
     * @generated from protobuf field: string state = 2;
     */
    state: string;
    /**
     * @generated from protobuf field: string attribute = 3;
     */
    attribute: string;
}
/**
 * ==================== IMPORT TIME ====================
 *
 * @generated from protobuf message GetTimeRequest
 */
export interface GetTimeRequest {
}
/**
 * @generated from protobuf message GetTimeResponse
 */
export interface GetTimeResponse {
    /**
     * @generated from protobuf field: fixed32 epoch_seconds = 1;
     */
    epochSeconds: number;
}
/**
 * @generated from protobuf message ListEntitiesServicesArgument
 */
export interface ListEntitiesServicesArgument {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: ServiceArgType type = 2;
     */
    type: ServiceArgType;
}
/**
 * @generated from protobuf message ListEntitiesServicesResponse
 */
export interface ListEntitiesServicesResponse {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: repeated ListEntitiesServicesArgument args = 3;
     */
    args: ListEntitiesServicesArgument[];
}
/**
 * @generated from protobuf message ExecuteServiceArgument
 */
export interface ExecuteServiceArgument {
    /**
     * @generated from protobuf field: bool bool_ = 1;
     */
    bool: boolean;
    /**
     * @generated from protobuf field: int32 legacy_int = 2;
     */
    legacyInt: number;
    /**
     * @generated from protobuf field: float float_ = 3;
     */
    float: number;
    /**
     * @generated from protobuf field: string string_ = 4;
     */
    string: string;
    /**
     * ESPHome 1.14 (api v1.3) make int a signed value
     *
     * @generated from protobuf field: sint32 int_ = 5;
     */
    int: number;
    /**
     * @generated from protobuf field: repeated bool bool_array = 6 [packed = false];
     */
    boolArray: boolean[];
    /**
     * @generated from protobuf field: repeated sint32 int_array = 7 [packed = false];
     */
    intArray: number[];
    /**
     * @generated from protobuf field: repeated float float_array = 8 [packed = false];
     */
    floatArray: number[];
    /**
     * @generated from protobuf field: repeated string string_array = 9;
     */
    stringArray: string[];
}
/**
 * @generated from protobuf message ExecuteServiceRequest
 */
export interface ExecuteServiceRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: repeated ExecuteServiceArgument args = 2;
     */
    args: ExecuteServiceArgument[];
}
/**
 * ==================== CAMERA ====================
 *
 * @generated from protobuf message ListEntitiesCameraResponse
 */
export interface ListEntitiesCameraResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: bool disabled_by_default = 5;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: string icon = 6;
     */
    icon: string;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 7;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message CameraImageResponse
 */
export interface CameraImageResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bytes data = 2;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: bool done = 3;
     */
    done: boolean;
}
/**
 * @generated from protobuf message CameraImageRequest
 */
export interface CameraImageRequest {
    /**
     * @generated from protobuf field: bool single = 1;
     */
    single: boolean;
    /**
     * @generated from protobuf field: bool stream = 2;
     */
    stream: boolean;
}
/**
 * @generated from protobuf message ListEntitiesClimateResponse
 */
export interface ListEntitiesClimateResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: bool supports_current_temperature = 5;
     */
    supportsCurrentTemperature: boolean;
    /**
     * @generated from protobuf field: bool supports_two_point_target_temperature = 6;
     */
    supportsTwoPointTargetTemperature: boolean;
    /**
     * @generated from protobuf field: repeated ClimateMode supported_modes = 7;
     */
    supportedModes: ClimateMode[];
    /**
     * @generated from protobuf field: float visual_min_temperature = 8;
     */
    visualMinTemperature: number;
    /**
     * @generated from protobuf field: float visual_max_temperature = 9;
     */
    visualMaxTemperature: number;
    /**
     * @generated from protobuf field: float visual_temperature_step = 10;
     */
    visualTemperatureStep: number;
    /**
     * for older peer versions - in new system this
     * is if CLIMATE_PRESET_AWAY exists is supported_presets
     *
     * @generated from protobuf field: bool legacy_supports_away = 11;
     */
    legacySupportsAway: boolean;
    /**
     * @generated from protobuf field: bool supports_action = 12;
     */
    supportsAction: boolean;
    /**
     * @generated from protobuf field: repeated ClimateFanMode supported_fan_modes = 13;
     */
    supportedFanModes: ClimateFanMode[];
    /**
     * @generated from protobuf field: repeated ClimateSwingMode supported_swing_modes = 14;
     */
    supportedSwingModes: ClimateSwingMode[];
    /**
     * @generated from protobuf field: repeated string supported_custom_fan_modes = 15;
     */
    supportedCustomFanModes: string[];
    /**
     * @generated from protobuf field: repeated ClimatePreset supported_presets = 16;
     */
    supportedPresets: ClimatePreset[];
    /**
     * @generated from protobuf field: repeated string supported_custom_presets = 17;
     */
    supportedCustomPresets: string[];
    /**
     * @generated from protobuf field: bool disabled_by_default = 18;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: string icon = 19;
     */
    icon: string;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 20;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message ClimateStateResponse
 */
export interface ClimateStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: ClimateMode mode = 2;
     */
    mode: ClimateMode;
    /**
     * @generated from protobuf field: float current_temperature = 3;
     */
    currentTemperature: number;
    /**
     * @generated from protobuf field: float target_temperature = 4;
     */
    targetTemperature: number;
    /**
     * @generated from protobuf field: float target_temperature_low = 5;
     */
    targetTemperatureLow: number;
    /**
     * @generated from protobuf field: float target_temperature_high = 6;
     */
    targetTemperatureHigh: number;
    /**
     * For older peers, equal to preset == CLIMATE_PRESET_AWAY
     *
     * @generated from protobuf field: bool legacy_away = 7;
     */
    legacyAway: boolean;
    /**
     * @generated from protobuf field: ClimateAction action = 8;
     */
    action: ClimateAction;
    /**
     * @generated from protobuf field: ClimateFanMode fan_mode = 9;
     */
    fanMode: ClimateFanMode;
    /**
     * @generated from protobuf field: ClimateSwingMode swing_mode = 10;
     */
    swingMode: ClimateSwingMode;
    /**
     * @generated from protobuf field: string custom_fan_mode = 11;
     */
    customFanMode: string;
    /**
     * @generated from protobuf field: ClimatePreset preset = 12;
     */
    preset: ClimatePreset;
    /**
     * @generated from protobuf field: string custom_preset = 13;
     */
    customPreset: string;
}
/**
 * @generated from protobuf message ClimateCommandRequest
 */
export interface ClimateCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool has_mode = 2;
     */
    hasMode: boolean;
    /**
     * @generated from protobuf field: ClimateMode mode = 3;
     */
    mode: ClimateMode;
    /**
     * @generated from protobuf field: bool has_target_temperature = 4;
     */
    hasTargetTemperature: boolean;
    /**
     * @generated from protobuf field: float target_temperature = 5;
     */
    targetTemperature: number;
    /**
     * @generated from protobuf field: bool has_target_temperature_low = 6;
     */
    hasTargetTemperatureLow: boolean;
    /**
     * @generated from protobuf field: float target_temperature_low = 7;
     */
    targetTemperatureLow: number;
    /**
     * @generated from protobuf field: bool has_target_temperature_high = 8;
     */
    hasTargetTemperatureHigh: boolean;
    /**
     * @generated from protobuf field: float target_temperature_high = 9;
     */
    targetTemperatureHigh: number;
    /**
     * legacy, for older peers, newer ones should use CLIMATE_PRESET_AWAY in preset
     *
     * @generated from protobuf field: bool has_legacy_away = 10;
     */
    hasLegacyAway: boolean;
    /**
     * @generated from protobuf field: bool legacy_away = 11;
     */
    legacyAway: boolean;
    /**
     * @generated from protobuf field: bool has_fan_mode = 12;
     */
    hasFanMode: boolean;
    /**
     * @generated from protobuf field: ClimateFanMode fan_mode = 13;
     */
    fanMode: ClimateFanMode;
    /**
     * @generated from protobuf field: bool has_swing_mode = 14;
     */
    hasSwingMode: boolean;
    /**
     * @generated from protobuf field: ClimateSwingMode swing_mode = 15;
     */
    swingMode: ClimateSwingMode;
    /**
     * @generated from protobuf field: bool has_custom_fan_mode = 16;
     */
    hasCustomFanMode: boolean;
    /**
     * @generated from protobuf field: string custom_fan_mode = 17;
     */
    customFanMode: string;
    /**
     * @generated from protobuf field: bool has_preset = 18;
     */
    hasPreset: boolean;
    /**
     * @generated from protobuf field: ClimatePreset preset = 19;
     */
    preset: ClimatePreset;
    /**
     * @generated from protobuf field: bool has_custom_preset = 20;
     */
    hasCustomPreset: boolean;
    /**
     * @generated from protobuf field: string custom_preset = 21;
     */
    customPreset: string;
}
/**
 * @generated from protobuf message ListEntitiesNumberResponse
 */
export interface ListEntitiesNumberResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: float min_value = 6;
     */
    minValue: number;
    /**
     * @generated from protobuf field: float max_value = 7;
     */
    maxValue: number;
    /**
     * @generated from protobuf field: float step = 8;
     */
    step: number;
    /**
     * @generated from protobuf field: bool disabled_by_default = 9;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 10;
     */
    entityCategory: EntityCategory;
    /**
     * @generated from protobuf field: string unit_of_measurement = 11;
     */
    unitOfMeasurement: string;
    /**
     * @generated from protobuf field: NumberMode mode = 12;
     */
    mode: NumberMode;
}
/**
 * @generated from protobuf message NumberStateResponse
 */
export interface NumberStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: float state = 2;
     */
    state: number;
    /**
     * If the number does not have a valid state yet.
     * Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
     *
     * @generated from protobuf field: bool missing_state = 3;
     */
    missingState: boolean;
}
/**
 * @generated from protobuf message NumberCommandRequest
 */
export interface NumberCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: float state = 2;
     */
    state: number;
}
/**
 * ==================== SELECT ====================
 *
 * @generated from protobuf message ListEntitiesSelectResponse
 */
export interface ListEntitiesSelectResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: repeated string options = 6;
     */
    options: string[];
    /**
     * @generated from protobuf field: bool disabled_by_default = 7;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 8;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message SelectStateResponse
 */
export interface SelectStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: string state = 2;
     */
    state: string;
    /**
     * If the select does not have a valid state yet.
     * Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
     *
     * @generated from protobuf field: bool missing_state = 3;
     */
    missingState: boolean;
}
/**
 * @generated from protobuf message SelectCommandRequest
 */
export interface SelectCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: string state = 2;
     */
    state: string;
}
/**
 * @generated from protobuf message ListEntitiesLockResponse
 */
export interface ListEntitiesLockResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: bool disabled_by_default = 6;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 7;
     */
    entityCategory: EntityCategory;
    /**
     * @generated from protobuf field: bool assumed_state = 8;
     */
    assumedState: boolean;
    /**
     * @generated from protobuf field: bool supports_open = 9;
     */
    supportsOpen: boolean;
    /**
     * @generated from protobuf field: bool requires_code = 10;
     */
    requiresCode: boolean;
    /**
     * Not yet implemented:
     *
     * @generated from protobuf field: string code_format = 11;
     */
    codeFormat: string;
}
/**
 * @generated from protobuf message LockStateResponse
 */
export interface LockStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: LockState state = 2;
     */
    state: LockState;
}
/**
 * @generated from protobuf message LockCommandRequest
 */
export interface LockCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: LockCommand command = 2;
     */
    command: LockCommand;
    /**
     * Not yet implemented:
     *
     * @generated from protobuf field: bool has_code = 3;
     */
    hasCode: boolean;
    /**
     * @generated from protobuf field: string code = 4;
     */
    code: string;
}
/**
 * ==================== BUTTON ====================
 *
 * @generated from protobuf message ListEntitiesButtonResponse
 */
export interface ListEntitiesButtonResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: bool disabled_by_default = 6;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 7;
     */
    entityCategory: EntityCategory;
    /**
     * @generated from protobuf field: string device_class = 8;
     */
    deviceClass: string;
}
/**
 * @generated from protobuf message ButtonCommandRequest
 */
export interface ButtonCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
}
// ==================== COMMON =====================

/**
 * @generated from protobuf enum EntityCategory
 */
export enum EntityCategory {
    /**
     * @generated from protobuf enum value: ENTITY_CATEGORY_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: ENTITY_CATEGORY_CONFIG = 1;
     */
    CONFIG = 1,
    /**
     * @generated from protobuf enum value: ENTITY_CATEGORY_DIAGNOSTIC = 2;
     */
    DIAGNOSTIC = 2
}
/**
 * @generated from protobuf enum LegacyCoverState
 */
export enum LegacyCoverState {
    /**
     * @generated from protobuf enum value: LEGACY_COVER_STATE_OPEN = 0;
     */
    OPEN = 0,
    /**
     * @generated from protobuf enum value: LEGACY_COVER_STATE_CLOSED = 1;
     */
    CLOSED = 1
}
/**
 * @generated from protobuf enum CoverOperation
 */
export enum CoverOperation {
    /**
     * @generated from protobuf enum value: COVER_OPERATION_IDLE = 0;
     */
    IDLE = 0,
    /**
     * @generated from protobuf enum value: COVER_OPERATION_IS_OPENING = 1;
     */
    IS_OPENING = 1,
    /**
     * @generated from protobuf enum value: COVER_OPERATION_IS_CLOSING = 2;
     */
    IS_CLOSING = 2
}
/**
 * @generated from protobuf enum LegacyCoverCommand
 */
export enum LegacyCoverCommand {
    /**
     * @generated from protobuf enum value: LEGACY_COVER_COMMAND_OPEN = 0;
     */
    OPEN = 0,
    /**
     * @generated from protobuf enum value: LEGACY_COVER_COMMAND_CLOSE = 1;
     */
    CLOSE = 1,
    /**
     * @generated from protobuf enum value: LEGACY_COVER_COMMAND_STOP = 2;
     */
    STOP = 2
}
/**
 * @generated from protobuf enum FanSpeed
 */
export enum FanSpeed {
    /**
     * @generated from protobuf enum value: FAN_SPEED_LOW = 0;
     */
    LOW = 0,
    /**
     * @generated from protobuf enum value: FAN_SPEED_MEDIUM = 1;
     */
    MEDIUM = 1,
    /**
     * @generated from protobuf enum value: FAN_SPEED_HIGH = 2;
     */
    HIGH = 2
}
/**
 * @generated from protobuf enum FanDirection
 */
export enum FanDirection {
    /**
     * @generated from protobuf enum value: FAN_DIRECTION_FORWARD = 0;
     */
    FORWARD = 0,
    /**
     * @generated from protobuf enum value: FAN_DIRECTION_REVERSE = 1;
     */
    REVERSE = 1
}
/**
 * ==================== LIGHT ====================
 *
 * @generated from protobuf enum ColorMode
 */
export enum ColorMode {
    /**
     * @generated from protobuf enum value: COLOR_MODE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: COLOR_MODE_ON_OFF = 1;
     */
    ON_OFF = 1,
    /**
     * @generated from protobuf enum value: COLOR_MODE_BRIGHTNESS = 2;
     */
    BRIGHTNESS = 2,
    /**
     * @generated from protobuf enum value: COLOR_MODE_WHITE = 7;
     */
    WHITE = 7,
    /**
     * @generated from protobuf enum value: COLOR_MODE_COLOR_TEMPERATURE = 11;
     */
    COLOR_TEMPERATURE = 11,
    /**
     * @generated from protobuf enum value: COLOR_MODE_COLD_WARM_WHITE = 19;
     */
    COLD_WARM_WHITE = 19,
    /**
     * @generated from protobuf enum value: COLOR_MODE_RGB = 35;
     */
    RGB = 35,
    /**
     * @generated from protobuf enum value: COLOR_MODE_RGB_WHITE = 39;
     */
    RGB_WHITE = 39,
    /**
     * @generated from protobuf enum value: COLOR_MODE_RGB_COLOR_TEMPERATURE = 47;
     */
    RGB_COLOR_TEMPERATURE = 47,
    /**
     * @generated from protobuf enum value: COLOR_MODE_RGB_COLD_WARM_WHITE = 51;
     */
    RGB_COLD_WARM_WHITE = 51
}
/**
 * ==================== SENSOR ====================
 *
 * @generated from protobuf enum SensorStateClass
 */
export enum SensorStateClass {
    /**
     * @generated from protobuf enum value: STATE_CLASS_NONE = 0;
     */
    STATE_CLASS_NONE = 0,
    /**
     * @generated from protobuf enum value: STATE_CLASS_MEASUREMENT = 1;
     */
    STATE_CLASS_MEASUREMENT = 1,
    /**
     * @generated from protobuf enum value: STATE_CLASS_TOTAL_INCREASING = 2;
     */
    STATE_CLASS_TOTAL_INCREASING = 2
}
/**
 * @generated from protobuf enum SensorLastResetType
 */
export enum SensorLastResetType {
    /**
     * @generated from protobuf enum value: LAST_RESET_NONE = 0;
     */
    LAST_RESET_NONE = 0,
    /**
     * @generated from protobuf enum value: LAST_RESET_NEVER = 1;
     */
    LAST_RESET_NEVER = 1,
    /**
     * @generated from protobuf enum value: LAST_RESET_AUTO = 2;
     */
    LAST_RESET_AUTO = 2
}
/**
 * ==================== SUBSCRIBE LOGS ====================
 *
 * @generated from protobuf enum LogLevel
 */
export enum LogLevel {
    /**
     * @generated from protobuf enum value: LOG_LEVEL_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_ERROR = 1;
     */
    ERROR = 1,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_WARN = 2;
     */
    WARN = 2,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_INFO = 3;
     */
    INFO = 3,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_CONFIG = 4;
     */
    CONFIG = 4,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_DEBUG = 5;
     */
    DEBUG = 5,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_VERBOSE = 6;
     */
    VERBOSE = 6,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_VERY_VERBOSE = 7;
     */
    VERY_VERBOSE = 7
}
/**
 * ==================== USER-DEFINES SERVICES ====================
 *
 * @generated from protobuf enum ServiceArgType
 */
export enum ServiceArgType {
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_BOOL = 0;
     */
    BOOL = 0,
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_INT = 1;
     */
    INT = 1,
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_FLOAT = 2;
     */
    FLOAT = 2,
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_STRING = 3;
     */
    STRING = 3,
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_BOOL_ARRAY = 4;
     */
    BOOL_ARRAY = 4,
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_INT_ARRAY = 5;
     */
    INT_ARRAY = 5,
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_FLOAT_ARRAY = 6;
     */
    FLOAT_ARRAY = 6,
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_STRING_ARRAY = 7;
     */
    STRING_ARRAY = 7
}
/**
 * ==================== CLIMATE ====================
 *
 * @generated from protobuf enum ClimateMode
 */
export enum ClimateMode {
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_OFF = 0;
     */
    OFF = 0,
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_HEAT_COOL = 1;
     */
    HEAT_COOL = 1,
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_COOL = 2;
     */
    COOL = 2,
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_HEAT = 3;
     */
    HEAT = 3,
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_FAN_ONLY = 4;
     */
    FAN_ONLY = 4,
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_DRY = 5;
     */
    DRY = 5,
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_AUTO = 6;
     */
    AUTO = 6
}
/**
 * @generated from protobuf enum ClimateFanMode
 */
export enum ClimateFanMode {
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_ON = 0;
     */
    CLIMATE_FAN_ON = 0,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_OFF = 1;
     */
    CLIMATE_FAN_OFF = 1,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_AUTO = 2;
     */
    CLIMATE_FAN_AUTO = 2,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_LOW = 3;
     */
    CLIMATE_FAN_LOW = 3,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_MEDIUM = 4;
     */
    CLIMATE_FAN_MEDIUM = 4,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_HIGH = 5;
     */
    CLIMATE_FAN_HIGH = 5,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_MIDDLE = 6;
     */
    CLIMATE_FAN_MIDDLE = 6,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_FOCUS = 7;
     */
    CLIMATE_FAN_FOCUS = 7,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_DIFFUSE = 8;
     */
    CLIMATE_FAN_DIFFUSE = 8
}
/**
 * @generated from protobuf enum ClimateSwingMode
 */
export enum ClimateSwingMode {
    /**
     * @generated from protobuf enum value: CLIMATE_SWING_OFF = 0;
     */
    CLIMATE_SWING_OFF = 0,
    /**
     * @generated from protobuf enum value: CLIMATE_SWING_BOTH = 1;
     */
    CLIMATE_SWING_BOTH = 1,
    /**
     * @generated from protobuf enum value: CLIMATE_SWING_VERTICAL = 2;
     */
    CLIMATE_SWING_VERTICAL = 2,
    /**
     * @generated from protobuf enum value: CLIMATE_SWING_HORIZONTAL = 3;
     */
    CLIMATE_SWING_HORIZONTAL = 3
}
/**
 * @generated from protobuf enum ClimateAction
 */
export enum ClimateAction {
    /**
     * @generated from protobuf enum value: CLIMATE_ACTION_OFF = 0;
     */
    OFF = 0,
    /**
     * values same as mode for readability
     *
     * @generated from protobuf enum value: CLIMATE_ACTION_COOLING = 2;
     */
    COOLING = 2,
    /**
     * @generated from protobuf enum value: CLIMATE_ACTION_HEATING = 3;
     */
    HEATING = 3,
    /**
     * @generated from protobuf enum value: CLIMATE_ACTION_IDLE = 4;
     */
    IDLE = 4,
    /**
     * @generated from protobuf enum value: CLIMATE_ACTION_DRYING = 5;
     */
    DRYING = 5,
    /**
     * @generated from protobuf enum value: CLIMATE_ACTION_FAN = 6;
     */
    FAN = 6
}
/**
 * @generated from protobuf enum ClimatePreset
 */
export enum ClimatePreset {
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_HOME = 1;
     */
    HOME = 1,
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_AWAY = 2;
     */
    AWAY = 2,
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_BOOST = 3;
     */
    BOOST = 3,
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_COMFORT = 4;
     */
    COMFORT = 4,
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_ECO = 5;
     */
    ECO = 5,
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_SLEEP = 6;
     */
    SLEEP = 6,
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_ACTIVITY = 7;
     */
    ACTIVITY = 7
}
/**
 * ==================== NUMBER ====================
 *
 * @generated from protobuf enum NumberMode
 */
export enum NumberMode {
    /**
     * @generated from protobuf enum value: NUMBER_MODE_AUTO = 0;
     */
    AUTO = 0,
    /**
     * @generated from protobuf enum value: NUMBER_MODE_BOX = 1;
     */
    BOX = 1,
    /**
     * @generated from protobuf enum value: NUMBER_MODE_SLIDER = 2;
     */
    SLIDER = 2
}
/**
 * ==================== LOCK ====================
 *
 * @generated from protobuf enum LockState
 */
export enum LockState {
    /**
     * @generated from protobuf enum value: LOCK_STATE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: LOCK_STATE_LOCKED = 1;
     */
    LOCKED = 1,
    /**
     * @generated from protobuf enum value: LOCK_STATE_UNLOCKED = 2;
     */
    UNLOCKED = 2,
    /**
     * @generated from protobuf enum value: LOCK_STATE_JAMMED = 3;
     */
    JAMMED = 3,
    /**
     * @generated from protobuf enum value: LOCK_STATE_LOCKING = 4;
     */
    LOCKING = 4,
    /**
     * @generated from protobuf enum value: LOCK_STATE_UNLOCKING = 5;
     */
    UNLOCKING = 5
}
/**
 * @generated from protobuf enum LockCommand
 */
export enum LockCommand {
    /**
     * @generated from protobuf enum value: LOCK_UNLOCK = 0;
     */
    LOCK_UNLOCK = 0,
    /**
     * @generated from protobuf enum value: LOCK_LOCK = 1;
     */
    LOCK_LOCK = 1,
    /**
     * @generated from protobuf enum value: LOCK_OPEN = 2;
     */
    LOCK_OPEN = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class HelloRequest$Type extends MessageType<HelloRequest> {
    constructor() {
        super("HelloRequest", [
            { no: 1, name: "client_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 1, source: "SOURCE_CLIENT", no_delay: true });
    }
    create(value?: PartialMessage<HelloRequest>): HelloRequest {
        const message = { clientInfo: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HelloRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HelloRequest): HelloRequest {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string client_info */ 1:
                    message.clientInfo = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HelloRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string client_info = 1; */
        if (message.clientInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientInfo);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HelloRequest
 */
export const HelloRequest = new HelloRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HelloResponse$Type extends MessageType<HelloResponse> {
    constructor() {
        super("HelloResponse", [
            { no: 1, name: "api_version_major", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "api_version_minor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "server_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 2, source: "SOURCE_SERVER", no_delay: true });
    }
    create(value?: PartialMessage<HelloResponse>): HelloResponse {
        const message = { apiVersionMajor: 0, apiVersionMinor: 0, serverInfo: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HelloResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HelloResponse): HelloResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 api_version_major */ 1:
                    message.apiVersionMajor = reader.uint32();
                    break;
                case /* uint32 api_version_minor */ 2:
                    message.apiVersionMinor = reader.uint32();
                    break;
                case /* string server_info */ 3:
                    message.serverInfo = reader.string();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HelloResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 api_version_major = 1; */
        if (message.apiVersionMajor !== 0)
            writer.tag(1, WireType.Varint).uint32(message.apiVersionMajor);
        /* uint32 api_version_minor = 2; */
        if (message.apiVersionMinor !== 0)
            writer.tag(2, WireType.Varint).uint32(message.apiVersionMinor);
        /* string server_info = 3; */
        if (message.serverInfo !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.serverInfo);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HelloResponse
 */
export const HelloResponse = new HelloResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectRequest$Type extends MessageType<ConnectRequest> {
    constructor() {
        super("ConnectRequest", [
            { no: 1, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 3, source: "SOURCE_CLIENT", no_delay: true });
    }
    create(value?: PartialMessage<ConnectRequest>): ConnectRequest {
        const message = { password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConnectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectRequest): ConnectRequest {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string password */ 1:
                    message.password = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string password = 1; */
        if (message.password !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.password);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ConnectRequest
 */
export const ConnectRequest = new ConnectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectResponse$Type extends MessageType<ConnectResponse> {
    constructor() {
        super("ConnectResponse", [
            { no: 1, name: "invalid_password", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 4, source: "SOURCE_SERVER", no_delay: true });
    }
    create(value?: PartialMessage<ConnectResponse>): ConnectResponse {
        const message = { invalidPassword: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConnectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectResponse): ConnectResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool invalid_password */ 1:
                    message.invalidPassword = reader.bool();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool invalid_password = 1; */
        if (message.invalidPassword !== false)
            writer.tag(1, WireType.Varint).bool(message.invalidPassword);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ConnectResponse
 */
export const ConnectResponse = new ConnectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisconnectRequest$Type extends MessageType<DisconnectRequest> {
    constructor() {
        super("DisconnectRequest", [], { id: 5, source: "SOURCE_BOTH", no_delay: true });
    }
    create(value?: PartialMessage<DisconnectRequest>): DisconnectRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DisconnectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisconnectRequest): DisconnectRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DisconnectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DisconnectRequest
 */
export const DisconnectRequest = new DisconnectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisconnectResponse$Type extends MessageType<DisconnectResponse> {
    constructor() {
        super("DisconnectResponse", [], { id: 6, source: "SOURCE_BOTH", no_delay: true });
    }
    create(value?: PartialMessage<DisconnectResponse>): DisconnectResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DisconnectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisconnectResponse): DisconnectResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DisconnectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DisconnectResponse
 */
export const DisconnectResponse = new DisconnectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingRequest$Type extends MessageType<PingRequest> {
    constructor() {
        super("PingRequest", [], { id: 7, source: "SOURCE_BOTH" });
    }
    create(value?: PartialMessage<PingRequest>): PingRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingRequest): PingRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PingRequest
 */
export const PingRequest = new PingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingResponse$Type extends MessageType<PingResponse> {
    constructor() {
        super("PingResponse", [], { id: 8, source: "SOURCE_BOTH" });
    }
    create(value?: PartialMessage<PingResponse>): PingResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingResponse): PingResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PingResponse
 */
export const PingResponse = new PingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceInfoRequest$Type extends MessageType<DeviceInfoRequest> {
    constructor() {
        super("DeviceInfoRequest", [], { id: 9, source: "SOURCE_CLIENT" });
    }
    create(value?: PartialMessage<DeviceInfoRequest>): DeviceInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeviceInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceInfoRequest): DeviceInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeviceInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeviceInfoRequest
 */
export const DeviceInfoRequest = new DeviceInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceInfoResponse$Type extends MessageType<DeviceInfoResponse> {
    constructor() {
        super("DeviceInfoResponse", [
            { no: 1, name: "uses_password", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "mac_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "esphome_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "compilation_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "model", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "has_deep_sleep", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "project_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "project_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "webserver_port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 10, source: "SOURCE_SERVER" });
    }
    create(value?: PartialMessage<DeviceInfoResponse>): DeviceInfoResponse {
        const message = { usesPassword: false, name: "", macAddress: "", esphomeVersion: "", compilationTime: "", model: "", hasDeepSleep: false, projectName: "", projectVersion: "", webserverPort: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeviceInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceInfoResponse): DeviceInfoResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool uses_password */ 1:
                    message.usesPassword = reader.bool();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string mac_address */ 3:
                    message.macAddress = reader.string();
                    break;
                case /* string esphome_version */ 4:
                    message.esphomeVersion = reader.string();
                    break;
                case /* string compilation_time */ 5:
                    message.compilationTime = reader.string();
                    break;
                case /* string model */ 6:
                    message.model = reader.string();
                    break;
                case /* bool has_deep_sleep */ 7:
                    message.hasDeepSleep = reader.bool();
                    break;
                case /* string project_name */ 8:
                    message.projectName = reader.string();
                    break;
                case /* string project_version */ 9:
                    message.projectVersion = reader.string();
                    break;
                case /* uint32 webserver_port */ 10:
                    message.webserverPort = reader.uint32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeviceInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool uses_password = 1; */
        if (message.usesPassword !== false)
            writer.tag(1, WireType.Varint).bool(message.usesPassword);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string mac_address = 3; */
        if (message.macAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.macAddress);
        /* string esphome_version = 4; */
        if (message.esphomeVersion !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.esphomeVersion);
        /* string compilation_time = 5; */
        if (message.compilationTime !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.compilationTime);
        /* string model = 6; */
        if (message.model !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.model);
        /* bool has_deep_sleep = 7; */
        if (message.hasDeepSleep !== false)
            writer.tag(7, WireType.Varint).bool(message.hasDeepSleep);
        /* string project_name = 8; */
        if (message.projectName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.projectName);
        /* string project_version = 9; */
        if (message.projectVersion !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.projectVersion);
        /* uint32 webserver_port = 10; */
        if (message.webserverPort !== 0)
            writer.tag(10, WireType.Varint).uint32(message.webserverPort);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeviceInfoResponse
 */
export const DeviceInfoResponse = new DeviceInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesRequest$Type extends MessageType<ListEntitiesRequest> {
    constructor() {
        super("ListEntitiesRequest", [], { id: 11, source: "SOURCE_CLIENT" });
    }
    create(value?: PartialMessage<ListEntitiesRequest>): ListEntitiesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesRequest): ListEntitiesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListEntitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesRequest
 */
export const ListEntitiesRequest = new ListEntitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesDoneResponse$Type extends MessageType<ListEntitiesDoneResponse> {
    constructor() {
        super("ListEntitiesDoneResponse", [], { id: 19, source: "SOURCE_SERVER", no_delay: true });
    }
    create(value?: PartialMessage<ListEntitiesDoneResponse>): ListEntitiesDoneResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesDoneResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesDoneResponse): ListEntitiesDoneResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListEntitiesDoneResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesDoneResponse
 */
export const ListEntitiesDoneResponse = new ListEntitiesDoneResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeStatesRequest$Type extends MessageType<SubscribeStatesRequest> {
    constructor() {
        super("SubscribeStatesRequest", [], { id: 20, source: "SOURCE_CLIENT" });
    }
    create(value?: PartialMessage<SubscribeStatesRequest>): SubscribeStatesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeStatesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeStatesRequest): SubscribeStatesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeStatesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeStatesRequest
 */
export const SubscribeStatesRequest = new SubscribeStatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesBinarySensorResponse$Type extends MessageType<ListEntitiesBinarySensorResponse> {
    constructor() {
        super("ListEntitiesBinarySensorResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "is_status_binary_sensor", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 12, source: "SOURCE_SERVER", ifdef: "USE_BINARY_SENSOR" });
    }
    create(value?: PartialMessage<ListEntitiesBinarySensorResponse>): ListEntitiesBinarySensorResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", deviceClass: "", isStatusBinarySensor: false, disabledByDefault: false, icon: "", entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesBinarySensorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesBinarySensorResponse): ListEntitiesBinarySensorResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string device_class */ 5:
                    message.deviceClass = reader.string();
                    break;
                case /* bool is_status_binary_sensor */ 6:
                    message.isStatusBinarySensor = reader.bool();
                    break;
                case /* bool disabled_by_default */ 7:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 8:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 9:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesBinarySensorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string device_class = 5; */
        if (message.deviceClass !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.deviceClass);
        /* bool is_status_binary_sensor = 6; */
        if (message.isStatusBinarySensor !== false)
            writer.tag(6, WireType.Varint).bool(message.isStatusBinarySensor);
        /* bool disabled_by_default = 7; */
        if (message.disabledByDefault !== false)
            writer.tag(7, WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 8; */
        if (message.icon !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 9; */
        if (message.entityCategory !== 0)
            writer.tag(9, WireType.Varint).int32(message.entityCategory);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesBinarySensorResponse
 */
export const ListEntitiesBinarySensorResponse = new ListEntitiesBinarySensorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinarySensorStateResponse$Type extends MessageType<BinarySensorStateResponse> {
    constructor() {
        super("BinarySensorStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "missing_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 21, source: "SOURCE_SERVER", ifdef: "USE_BINARY_SENSOR", no_delay: true });
    }
    create(value?: PartialMessage<BinarySensorStateResponse>): BinarySensorStateResponse {
        const message = { key: 0, state: false, missingState: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BinarySensorStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinarySensorStateResponse): BinarySensorStateResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                case /* bool missing_state */ 3:
                    message.missingState = reader.bool();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinarySensorStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, WireType.Varint).bool(message.state);
        /* bool missing_state = 3; */
        if (message.missingState !== false)
            writer.tag(3, WireType.Varint).bool(message.missingState);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BinarySensorStateResponse
 */
export const BinarySensorStateResponse = new BinarySensorStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesCoverResponse$Type extends MessageType<ListEntitiesCoverResponse> {
    constructor() {
        super("ListEntitiesCoverResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "assumed_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "supports_position", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "supports_tilt", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 13, source: "SOURCE_SERVER", ifdef: "USE_COVER" });
    }
    create(value?: PartialMessage<ListEntitiesCoverResponse>): ListEntitiesCoverResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", assumedState: false, supportsPosition: false, supportsTilt: false, deviceClass: "", disabledByDefault: false, icon: "", entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesCoverResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesCoverResponse): ListEntitiesCoverResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* bool assumed_state */ 5:
                    message.assumedState = reader.bool();
                    break;
                case /* bool supports_position */ 6:
                    message.supportsPosition = reader.bool();
                    break;
                case /* bool supports_tilt */ 7:
                    message.supportsTilt = reader.bool();
                    break;
                case /* string device_class */ 8:
                    message.deviceClass = reader.string();
                    break;
                case /* bool disabled_by_default */ 9:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 10:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 11:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesCoverResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* bool assumed_state = 5; */
        if (message.assumedState !== false)
            writer.tag(5, WireType.Varint).bool(message.assumedState);
        /* bool supports_position = 6; */
        if (message.supportsPosition !== false)
            writer.tag(6, WireType.Varint).bool(message.supportsPosition);
        /* bool supports_tilt = 7; */
        if (message.supportsTilt !== false)
            writer.tag(7, WireType.Varint).bool(message.supportsTilt);
        /* string device_class = 8; */
        if (message.deviceClass !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.deviceClass);
        /* bool disabled_by_default = 9; */
        if (message.disabledByDefault !== false)
            writer.tag(9, WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 10; */
        if (message.icon !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 11; */
        if (message.entityCategory !== 0)
            writer.tag(11, WireType.Varint).int32(message.entityCategory);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesCoverResponse
 */
export const ListEntitiesCoverResponse = new ListEntitiesCoverResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoverStateResponse$Type extends MessageType<CoverStateResponse> {
    constructor() {
        super("CoverStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "legacy_state", kind: "enum", T: () => ["LegacyCoverState", LegacyCoverState, "LEGACY_COVER_STATE_"] },
            { no: 3, name: "position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "tilt", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "current_operation", kind: "enum", T: () => ["CoverOperation", CoverOperation, "COVER_OPERATION_"] }
        ], { id: 22, source: "SOURCE_SERVER", ifdef: "USE_COVER", no_delay: true });
    }
    create(value?: PartialMessage<CoverStateResponse>): CoverStateResponse {
        const message = { key: 0, legacyState: 0, position: 0, tilt: 0, currentOperation: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CoverStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoverStateResponse): CoverStateResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* LegacyCoverState legacy_state */ 2:
                    message.legacyState = reader.int32();
                    break;
                case /* float position */ 3:
                    message.position = reader.float();
                    break;
                case /* float tilt */ 4:
                    message.tilt = reader.float();
                    break;
                case /* CoverOperation current_operation */ 5:
                    message.currentOperation = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CoverStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* LegacyCoverState legacy_state = 2; */
        if (message.legacyState !== 0)
            writer.tag(2, WireType.Varint).int32(message.legacyState);
        /* float position = 3; */
        if (message.position !== 0)
            writer.tag(3, WireType.Bit32).float(message.position);
        /* float tilt = 4; */
        if (message.tilt !== 0)
            writer.tag(4, WireType.Bit32).float(message.tilt);
        /* CoverOperation current_operation = 5; */
        if (message.currentOperation !== 0)
            writer.tag(5, WireType.Varint).int32(message.currentOperation);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CoverStateResponse
 */
export const CoverStateResponse = new CoverStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoverCommandRequest$Type extends MessageType<CoverCommandRequest> {
    constructor() {
        super("CoverCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_legacy_command", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "legacy_command", kind: "enum", T: () => ["LegacyCoverCommand", LegacyCoverCommand, "LEGACY_COVER_COMMAND_"] },
            { no: 4, name: "has_position", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "has_tilt", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "tilt", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "stop", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 30, source: "SOURCE_CLIENT", ifdef: "USE_COVER", no_delay: true });
    }
    create(value?: PartialMessage<CoverCommandRequest>): CoverCommandRequest {
        const message = { key: 0, hasLegacyCommand: false, legacyCommand: 0, hasPosition: false, position: 0, hasTilt: false, tilt: 0, stop: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CoverCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoverCommandRequest): CoverCommandRequest {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_legacy_command */ 2:
                    message.hasLegacyCommand = reader.bool();
                    break;
                case /* LegacyCoverCommand legacy_command */ 3:
                    message.legacyCommand = reader.int32();
                    break;
                case /* bool has_position */ 4:
                    message.hasPosition = reader.bool();
                    break;
                case /* float position */ 5:
                    message.position = reader.float();
                    break;
                case /* bool has_tilt */ 6:
                    message.hasTilt = reader.bool();
                    break;
                case /* float tilt */ 7:
                    message.tilt = reader.float();
                    break;
                case /* bool stop */ 8:
                    message.stop = reader.bool();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CoverCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool has_legacy_command = 2; */
        if (message.hasLegacyCommand !== false)
            writer.tag(2, WireType.Varint).bool(message.hasLegacyCommand);
        /* LegacyCoverCommand legacy_command = 3; */
        if (message.legacyCommand !== 0)
            writer.tag(3, WireType.Varint).int32(message.legacyCommand);
        /* bool has_position = 4; */
        if (message.hasPosition !== false)
            writer.tag(4, WireType.Varint).bool(message.hasPosition);
        /* float position = 5; */
        if (message.position !== 0)
            writer.tag(5, WireType.Bit32).float(message.position);
        /* bool has_tilt = 6; */
        if (message.hasTilt !== false)
            writer.tag(6, WireType.Varint).bool(message.hasTilt);
        /* float tilt = 7; */
        if (message.tilt !== 0)
            writer.tag(7, WireType.Bit32).float(message.tilt);
        /* bool stop = 8; */
        if (message.stop !== false)
            writer.tag(8, WireType.Varint).bool(message.stop);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CoverCommandRequest
 */
export const CoverCommandRequest = new CoverCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesFanResponse$Type extends MessageType<ListEntitiesFanResponse> {
    constructor() {
        super("ListEntitiesFanResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "supports_oscillation", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "supports_speed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "supports_direction", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "supported_speed_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 14, source: "SOURCE_SERVER", ifdef: "USE_FAN" });
    }
    create(value?: PartialMessage<ListEntitiesFanResponse>): ListEntitiesFanResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", supportsOscillation: false, supportsSpeed: false, supportsDirection: false, supportedSpeedCount: 0, disabledByDefault: false, icon: "", entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesFanResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesFanResponse): ListEntitiesFanResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* bool supports_oscillation */ 5:
                    message.supportsOscillation = reader.bool();
                    break;
                case /* bool supports_speed */ 6:
                    message.supportsSpeed = reader.bool();
                    break;
                case /* bool supports_direction */ 7:
                    message.supportsDirection = reader.bool();
                    break;
                case /* int32 supported_speed_count */ 8:
                    message.supportedSpeedCount = reader.int32();
                    break;
                case /* bool disabled_by_default */ 9:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 10:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 11:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesFanResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* bool supports_oscillation = 5; */
        if (message.supportsOscillation !== false)
            writer.tag(5, WireType.Varint).bool(message.supportsOscillation);
        /* bool supports_speed = 6; */
        if (message.supportsSpeed !== false)
            writer.tag(6, WireType.Varint).bool(message.supportsSpeed);
        /* bool supports_direction = 7; */
        if (message.supportsDirection !== false)
            writer.tag(7, WireType.Varint).bool(message.supportsDirection);
        /* int32 supported_speed_count = 8; */
        if (message.supportedSpeedCount !== 0)
            writer.tag(8, WireType.Varint).int32(message.supportedSpeedCount);
        /* bool disabled_by_default = 9; */
        if (message.disabledByDefault !== false)
            writer.tag(9, WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 10; */
        if (message.icon !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 11; */
        if (message.entityCategory !== 0)
            writer.tag(11, WireType.Varint).int32(message.entityCategory);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesFanResponse
 */
export const ListEntitiesFanResponse = new ListEntitiesFanResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FanStateResponse$Type extends MessageType<FanStateResponse> {
    constructor() {
        super("FanStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "oscillating", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "speed", kind: "enum", T: () => ["FanSpeed", FanSpeed, "FAN_SPEED_"] },
            { no: 5, name: "direction", kind: "enum", T: () => ["FanDirection", FanDirection, "FAN_DIRECTION_"] },
            { no: 6, name: "speed_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 23, source: "SOURCE_SERVER", ifdef: "USE_FAN", no_delay: true });
    }
    create(value?: PartialMessage<FanStateResponse>): FanStateResponse {
        const message = { key: 0, state: false, oscillating: false, speed: 0, direction: 0, speedLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FanStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FanStateResponse): FanStateResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                case /* bool oscillating */ 3:
                    message.oscillating = reader.bool();
                    break;
                case /* FanSpeed speed = 4 [deprecated = true];*/ 4:
                    message.speed = reader.int32();
                    break;
                case /* FanDirection direction */ 5:
                    message.direction = reader.int32();
                    break;
                case /* int32 speed_level */ 6:
                    message.speedLevel = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FanStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, WireType.Varint).bool(message.state);
        /* bool oscillating = 3; */
        if (message.oscillating !== false)
            writer.tag(3, WireType.Varint).bool(message.oscillating);
        /* FanSpeed speed = 4 [deprecated = true]; */
        if (message.speed !== 0)
            writer.tag(4, WireType.Varint).int32(message.speed);
        /* FanDirection direction = 5; */
        if (message.direction !== 0)
            writer.tag(5, WireType.Varint).int32(message.direction);
        /* int32 speed_level = 6; */
        if (message.speedLevel !== 0)
            writer.tag(6, WireType.Varint).int32(message.speedLevel);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FanStateResponse
 */
export const FanStateResponse = new FanStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FanCommandRequest$Type extends MessageType<FanCommandRequest> {
    constructor() {
        super("FanCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "has_speed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "speed", kind: "enum", T: () => ["FanSpeed", FanSpeed, "FAN_SPEED_"] },
            { no: 6, name: "has_oscillating", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "oscillating", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "has_direction", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "direction", kind: "enum", T: () => ["FanDirection", FanDirection, "FAN_DIRECTION_"] },
            { no: 10, name: "has_speed_level", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "speed_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 31, source: "SOURCE_CLIENT", ifdef: "USE_FAN", no_delay: true });
    }
    create(value?: PartialMessage<FanCommandRequest>): FanCommandRequest {
        const message = { key: 0, hasState: false, state: false, hasSpeed: false, speed: 0, hasOscillating: false, oscillating: false, hasDirection: false, direction: 0, hasSpeedLevel: false, speedLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FanCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FanCommandRequest): FanCommandRequest {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_state */ 2:
                    message.hasState = reader.bool();
                    break;
                case /* bool state */ 3:
                    message.state = reader.bool();
                    break;
                case /* bool has_speed = 4 [deprecated = true];*/ 4:
                    message.hasSpeed = reader.bool();
                    break;
                case /* FanSpeed speed = 5 [deprecated = true];*/ 5:
                    message.speed = reader.int32();
                    break;
                case /* bool has_oscillating */ 6:
                    message.hasOscillating = reader.bool();
                    break;
                case /* bool oscillating */ 7:
                    message.oscillating = reader.bool();
                    break;
                case /* bool has_direction */ 8:
                    message.hasDirection = reader.bool();
                    break;
                case /* FanDirection direction */ 9:
                    message.direction = reader.int32();
                    break;
                case /* bool has_speed_level */ 10:
                    message.hasSpeedLevel = reader.bool();
                    break;
                case /* int32 speed_level */ 11:
                    message.speedLevel = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FanCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool has_state = 2; */
        if (message.hasState !== false)
            writer.tag(2, WireType.Varint).bool(message.hasState);
        /* bool state = 3; */
        if (message.state !== false)
            writer.tag(3, WireType.Varint).bool(message.state);
        /* bool has_speed = 4 [deprecated = true]; */
        if (message.hasSpeed !== false)
            writer.tag(4, WireType.Varint).bool(message.hasSpeed);
        /* FanSpeed speed = 5 [deprecated = true]; */
        if (message.speed !== 0)
            writer.tag(5, WireType.Varint).int32(message.speed);
        /* bool has_oscillating = 6; */
        if (message.hasOscillating !== false)
            writer.tag(6, WireType.Varint).bool(message.hasOscillating);
        /* bool oscillating = 7; */
        if (message.oscillating !== false)
            writer.tag(7, WireType.Varint).bool(message.oscillating);
        /* bool has_direction = 8; */
        if (message.hasDirection !== false)
            writer.tag(8, WireType.Varint).bool(message.hasDirection);
        /* FanDirection direction = 9; */
        if (message.direction !== 0)
            writer.tag(9, WireType.Varint).int32(message.direction);
        /* bool has_speed_level = 10; */
        if (message.hasSpeedLevel !== false)
            writer.tag(10, WireType.Varint).bool(message.hasSpeedLevel);
        /* int32 speed_level = 11; */
        if (message.speedLevel !== 0)
            writer.tag(11, WireType.Varint).int32(message.speedLevel);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FanCommandRequest
 */
export const FanCommandRequest = new FanCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesLightResponse$Type extends MessageType<ListEntitiesLightResponse> {
    constructor() {
        super("ListEntitiesLightResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "supported_color_modes", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["ColorMode", ColorMode, "COLOR_MODE_"] },
            { no: 5, name: "legacy_supports_brightness", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "legacy_supports_rgb", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "legacy_supports_white_value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "legacy_supports_color_temperature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "min_mireds", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "max_mireds", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "effects", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 15, source: "SOURCE_SERVER", ifdef: "USE_LIGHT" });
    }
    create(value?: PartialMessage<ListEntitiesLightResponse>): ListEntitiesLightResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", supportedColorModes: [], legacySupportsBrightness: false, legacySupportsRgb: false, legacySupportsWhiteValue: false, legacySupportsColorTemperature: false, minMireds: 0, maxMireds: 0, effects: [], disabledByDefault: false, icon: "", entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesLightResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesLightResponse): ListEntitiesLightResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* repeated ColorMode supported_color_modes */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedColorModes.push(reader.int32());
                    else
                        message.supportedColorModes.push(reader.int32());
                    break;
                case /* bool legacy_supports_brightness = 5 [deprecated = true];*/ 5:
                    message.legacySupportsBrightness = reader.bool();
                    break;
                case /* bool legacy_supports_rgb = 6 [deprecated = true];*/ 6:
                    message.legacySupportsRgb = reader.bool();
                    break;
                case /* bool legacy_supports_white_value = 7 [deprecated = true];*/ 7:
                    message.legacySupportsWhiteValue = reader.bool();
                    break;
                case /* bool legacy_supports_color_temperature = 8 [deprecated = true];*/ 8:
                    message.legacySupportsColorTemperature = reader.bool();
                    break;
                case /* float min_mireds */ 9:
                    message.minMireds = reader.float();
                    break;
                case /* float max_mireds */ 10:
                    message.maxMireds = reader.float();
                    break;
                case /* repeated string effects */ 11:
                    message.effects.push(reader.string());
                    break;
                case /* bool disabled_by_default */ 13:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 14:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 15:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesLightResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* repeated ColorMode supported_color_modes = 12; */
        if (message.supportedColorModes.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedColorModes.length; i++)
                writer.int32(message.supportedColorModes[i]);
            writer.join();
        }
        /* bool legacy_supports_brightness = 5 [deprecated = true]; */
        if (message.legacySupportsBrightness !== false)
            writer.tag(5, WireType.Varint).bool(message.legacySupportsBrightness);
        /* bool legacy_supports_rgb = 6 [deprecated = true]; */
        if (message.legacySupportsRgb !== false)
            writer.tag(6, WireType.Varint).bool(message.legacySupportsRgb);
        /* bool legacy_supports_white_value = 7 [deprecated = true]; */
        if (message.legacySupportsWhiteValue !== false)
            writer.tag(7, WireType.Varint).bool(message.legacySupportsWhiteValue);
        /* bool legacy_supports_color_temperature = 8 [deprecated = true]; */
        if (message.legacySupportsColorTemperature !== false)
            writer.tag(8, WireType.Varint).bool(message.legacySupportsColorTemperature);
        /* float min_mireds = 9; */
        if (message.minMireds !== 0)
            writer.tag(9, WireType.Bit32).float(message.minMireds);
        /* float max_mireds = 10; */
        if (message.maxMireds !== 0)
            writer.tag(10, WireType.Bit32).float(message.maxMireds);
        /* repeated string effects = 11; */
        for (let i = 0; i < message.effects.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.effects[i]);
        /* bool disabled_by_default = 13; */
        if (message.disabledByDefault !== false)
            writer.tag(13, WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 14; */
        if (message.icon !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 15; */
        if (message.entityCategory !== 0)
            writer.tag(15, WireType.Varint).int32(message.entityCategory);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesLightResponse
 */
export const ListEntitiesLightResponse = new ListEntitiesLightResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LightStateResponse$Type extends MessageType<LightStateResponse> {
    constructor() {
        super("LightStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "brightness", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "color_mode", kind: "enum", T: () => ["ColorMode", ColorMode, "COLOR_MODE_"] },
            { no: 10, name: "color_brightness", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "red", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "green", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "blue", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "color_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "cold_white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "warm_white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "effect", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 24, source: "SOURCE_SERVER", ifdef: "USE_LIGHT", no_delay: true });
    }
    create(value?: PartialMessage<LightStateResponse>): LightStateResponse {
        const message = { key: 0, state: false, brightness: 0, colorMode: 0, colorBrightness: 0, red: 0, green: 0, blue: 0, white: 0, colorTemperature: 0, coldWhite: 0, warmWhite: 0, effect: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LightStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LightStateResponse): LightStateResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                case /* float brightness */ 3:
                    message.brightness = reader.float();
                    break;
                case /* ColorMode color_mode */ 11:
                    message.colorMode = reader.int32();
                    break;
                case /* float color_brightness */ 10:
                    message.colorBrightness = reader.float();
                    break;
                case /* float red */ 4:
                    message.red = reader.float();
                    break;
                case /* float green */ 5:
                    message.green = reader.float();
                    break;
                case /* float blue */ 6:
                    message.blue = reader.float();
                    break;
                case /* float white */ 7:
                    message.white = reader.float();
                    break;
                case /* float color_temperature */ 8:
                    message.colorTemperature = reader.float();
                    break;
                case /* float cold_white */ 12:
                    message.coldWhite = reader.float();
                    break;
                case /* float warm_white */ 13:
                    message.warmWhite = reader.float();
                    break;
                case /* string effect */ 9:
                    message.effect = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LightStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, WireType.Varint).bool(message.state);
        /* float brightness = 3; */
        if (message.brightness !== 0)
            writer.tag(3, WireType.Bit32).float(message.brightness);
        /* ColorMode color_mode = 11; */
        if (message.colorMode !== 0)
            writer.tag(11, WireType.Varint).int32(message.colorMode);
        /* float color_brightness = 10; */
        if (message.colorBrightness !== 0)
            writer.tag(10, WireType.Bit32).float(message.colorBrightness);
        /* float red = 4; */
        if (message.red !== 0)
            writer.tag(4, WireType.Bit32).float(message.red);
        /* float green = 5; */
        if (message.green !== 0)
            writer.tag(5, WireType.Bit32).float(message.green);
        /* float blue = 6; */
        if (message.blue !== 0)
            writer.tag(6, WireType.Bit32).float(message.blue);
        /* float white = 7; */
        if (message.white !== 0)
            writer.tag(7, WireType.Bit32).float(message.white);
        /* float color_temperature = 8; */
        if (message.colorTemperature !== 0)
            writer.tag(8, WireType.Bit32).float(message.colorTemperature);
        /* float cold_white = 12; */
        if (message.coldWhite !== 0)
            writer.tag(12, WireType.Bit32).float(message.coldWhite);
        /* float warm_white = 13; */
        if (message.warmWhite !== 0)
            writer.tag(13, WireType.Bit32).float(message.warmWhite);
        /* string effect = 9; */
        if (message.effect !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.effect);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LightStateResponse
 */
export const LightStateResponse = new LightStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LightCommandRequest$Type extends MessageType<LightCommandRequest> {
    constructor() {
        super("LightCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "has_brightness", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "brightness", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 22, name: "has_color_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "color_mode", kind: "enum", T: () => ["ColorMode", ColorMode, "COLOR_MODE_"] },
            { no: 20, name: "has_color_brightness", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "color_brightness", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "has_rgb", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "red", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "green", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "blue", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "has_white", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "has_color_temperature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "color_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 24, name: "has_cold_white", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 25, name: "cold_white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 26, name: "has_warm_white", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "warm_white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "has_transition_length", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "transition_length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "has_flash_length", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "flash_length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "has_effect", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "effect", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 32, source: "SOURCE_CLIENT", ifdef: "USE_LIGHT", no_delay: true });
    }
    create(value?: PartialMessage<LightCommandRequest>): LightCommandRequest {
        const message = { key: 0, hasState: false, state: false, hasBrightness: false, brightness: 0, hasColorMode: false, colorMode: 0, hasColorBrightness: false, colorBrightness: 0, hasRgb: false, red: 0, green: 0, blue: 0, hasWhite: false, white: 0, hasColorTemperature: false, colorTemperature: 0, hasColdWhite: false, coldWhite: 0, hasWarmWhite: false, warmWhite: 0, hasTransitionLength: false, transitionLength: 0, hasFlashLength: false, flashLength: 0, hasEffect: false, effect: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LightCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LightCommandRequest): LightCommandRequest {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_state */ 2:
                    message.hasState = reader.bool();
                    break;
                case /* bool state */ 3:
                    message.state = reader.bool();
                    break;
                case /* bool has_brightness */ 4:
                    message.hasBrightness = reader.bool();
                    break;
                case /* float brightness */ 5:
                    message.brightness = reader.float();
                    break;
                case /* bool has_color_mode */ 22:
                    message.hasColorMode = reader.bool();
                    break;
                case /* ColorMode color_mode */ 23:
                    message.colorMode = reader.int32();
                    break;
                case /* bool has_color_brightness */ 20:
                    message.hasColorBrightness = reader.bool();
                    break;
                case /* float color_brightness */ 21:
                    message.colorBrightness = reader.float();
                    break;
                case /* bool has_rgb */ 6:
                    message.hasRgb = reader.bool();
                    break;
                case /* float red */ 7:
                    message.red = reader.float();
                    break;
                case /* float green */ 8:
                    message.green = reader.float();
                    break;
                case /* float blue */ 9:
                    message.blue = reader.float();
                    break;
                case /* bool has_white */ 10:
                    message.hasWhite = reader.bool();
                    break;
                case /* float white */ 11:
                    message.white = reader.float();
                    break;
                case /* bool has_color_temperature */ 12:
                    message.hasColorTemperature = reader.bool();
                    break;
                case /* float color_temperature */ 13:
                    message.colorTemperature = reader.float();
                    break;
                case /* bool has_cold_white */ 24:
                    message.hasColdWhite = reader.bool();
                    break;
                case /* float cold_white */ 25:
                    message.coldWhite = reader.float();
                    break;
                case /* bool has_warm_white */ 26:
                    message.hasWarmWhite = reader.bool();
                    break;
                case /* float warm_white */ 27:
                    message.warmWhite = reader.float();
                    break;
                case /* bool has_transition_length */ 14:
                    message.hasTransitionLength = reader.bool();
                    break;
                case /* uint32 transition_length */ 15:
                    message.transitionLength = reader.uint32();
                    break;
                case /* bool has_flash_length */ 16:
                    message.hasFlashLength = reader.bool();
                    break;
                case /* uint32 flash_length */ 17:
                    message.flashLength = reader.uint32();
                    break;
                case /* bool has_effect */ 18:
                    message.hasEffect = reader.bool();
                    break;
                case /* string effect */ 19:
                    message.effect = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LightCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool has_state = 2; */
        if (message.hasState !== false)
            writer.tag(2, WireType.Varint).bool(message.hasState);
        /* bool state = 3; */
        if (message.state !== false)
            writer.tag(3, WireType.Varint).bool(message.state);
        /* bool has_brightness = 4; */
        if (message.hasBrightness !== false)
            writer.tag(4, WireType.Varint).bool(message.hasBrightness);
        /* float brightness = 5; */
        if (message.brightness !== 0)
            writer.tag(5, WireType.Bit32).float(message.brightness);
        /* bool has_color_mode = 22; */
        if (message.hasColorMode !== false)
            writer.tag(22, WireType.Varint).bool(message.hasColorMode);
        /* ColorMode color_mode = 23; */
        if (message.colorMode !== 0)
            writer.tag(23, WireType.Varint).int32(message.colorMode);
        /* bool has_color_brightness = 20; */
        if (message.hasColorBrightness !== false)
            writer.tag(20, WireType.Varint).bool(message.hasColorBrightness);
        /* float color_brightness = 21; */
        if (message.colorBrightness !== 0)
            writer.tag(21, WireType.Bit32).float(message.colorBrightness);
        /* bool has_rgb = 6; */
        if (message.hasRgb !== false)
            writer.tag(6, WireType.Varint).bool(message.hasRgb);
        /* float red = 7; */
        if (message.red !== 0)
            writer.tag(7, WireType.Bit32).float(message.red);
        /* float green = 8; */
        if (message.green !== 0)
            writer.tag(8, WireType.Bit32).float(message.green);
        /* float blue = 9; */
        if (message.blue !== 0)
            writer.tag(9, WireType.Bit32).float(message.blue);
        /* bool has_white = 10; */
        if (message.hasWhite !== false)
            writer.tag(10, WireType.Varint).bool(message.hasWhite);
        /* float white = 11; */
        if (message.white !== 0)
            writer.tag(11, WireType.Bit32).float(message.white);
        /* bool has_color_temperature = 12; */
        if (message.hasColorTemperature !== false)
            writer.tag(12, WireType.Varint).bool(message.hasColorTemperature);
        /* float color_temperature = 13; */
        if (message.colorTemperature !== 0)
            writer.tag(13, WireType.Bit32).float(message.colorTemperature);
        /* bool has_cold_white = 24; */
        if (message.hasColdWhite !== false)
            writer.tag(24, WireType.Varint).bool(message.hasColdWhite);
        /* float cold_white = 25; */
        if (message.coldWhite !== 0)
            writer.tag(25, WireType.Bit32).float(message.coldWhite);
        /* bool has_warm_white = 26; */
        if (message.hasWarmWhite !== false)
            writer.tag(26, WireType.Varint).bool(message.hasWarmWhite);
        /* float warm_white = 27; */
        if (message.warmWhite !== 0)
            writer.tag(27, WireType.Bit32).float(message.warmWhite);
        /* bool has_transition_length = 14; */
        if (message.hasTransitionLength !== false)
            writer.tag(14, WireType.Varint).bool(message.hasTransitionLength);
        /* uint32 transition_length = 15; */
        if (message.transitionLength !== 0)
            writer.tag(15, WireType.Varint).uint32(message.transitionLength);
        /* bool has_flash_length = 16; */
        if (message.hasFlashLength !== false)
            writer.tag(16, WireType.Varint).bool(message.hasFlashLength);
        /* uint32 flash_length = 17; */
        if (message.flashLength !== 0)
            writer.tag(17, WireType.Varint).uint32(message.flashLength);
        /* bool has_effect = 18; */
        if (message.hasEffect !== false)
            writer.tag(18, WireType.Varint).bool(message.hasEffect);
        /* string effect = 19; */
        if (message.effect !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.effect);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LightCommandRequest
 */
export const LightCommandRequest = new LightCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesSensorResponse$Type extends MessageType<ListEntitiesSensorResponse> {
    constructor() {
        super("ListEntitiesSensorResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "unit_of_measurement", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "accuracy_decimals", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "force_update", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "state_class", kind: "enum", T: () => ["SensorStateClass", SensorStateClass] },
            { no: 11, name: "legacy_last_reset_type", kind: "enum", T: () => ["SensorLastResetType", SensorLastResetType] },
            { no: 12, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 16, source: "SOURCE_SERVER", ifdef: "USE_SENSOR" });
    }
    create(value?: PartialMessage<ListEntitiesSensorResponse>): ListEntitiesSensorResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", unitOfMeasurement: "", accuracyDecimals: 0, forceUpdate: false, deviceClass: "", stateClass: 0, legacyLastResetType: 0, disabledByDefault: false, entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesSensorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesSensorResponse): ListEntitiesSensorResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* string unit_of_measurement */ 6:
                    message.unitOfMeasurement = reader.string();
                    break;
                case /* int32 accuracy_decimals */ 7:
                    message.accuracyDecimals = reader.int32();
                    break;
                case /* bool force_update */ 8:
                    message.forceUpdate = reader.bool();
                    break;
                case /* string device_class */ 9:
                    message.deviceClass = reader.string();
                    break;
                case /* SensorStateClass state_class */ 10:
                    message.stateClass = reader.int32();
                    break;
                case /* SensorLastResetType legacy_last_reset_type */ 11:
                    message.legacyLastResetType = reader.int32();
                    break;
                case /* bool disabled_by_default */ 12:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 13:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesSensorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* string unit_of_measurement = 6; */
        if (message.unitOfMeasurement !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.unitOfMeasurement);
        /* int32 accuracy_decimals = 7; */
        if (message.accuracyDecimals !== 0)
            writer.tag(7, WireType.Varint).int32(message.accuracyDecimals);
        /* bool force_update = 8; */
        if (message.forceUpdate !== false)
            writer.tag(8, WireType.Varint).bool(message.forceUpdate);
        /* string device_class = 9; */
        if (message.deviceClass !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.deviceClass);
        /* SensorStateClass state_class = 10; */
        if (message.stateClass !== 0)
            writer.tag(10, WireType.Varint).int32(message.stateClass);
        /* SensorLastResetType legacy_last_reset_type = 11; */
        if (message.legacyLastResetType !== 0)
            writer.tag(11, WireType.Varint).int32(message.legacyLastResetType);
        /* bool disabled_by_default = 12; */
        if (message.disabledByDefault !== false)
            writer.tag(12, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 13; */
        if (message.entityCategory !== 0)
            writer.tag(13, WireType.Varint).int32(message.entityCategory);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesSensorResponse
 */
export const ListEntitiesSensorResponse = new ListEntitiesSensorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorStateResponse$Type extends MessageType<SensorStateResponse> {
    constructor() {
        super("SensorStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "missing_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 25, source: "SOURCE_SERVER", ifdef: "USE_SENSOR", no_delay: true });
    }
    create(value?: PartialMessage<SensorStateResponse>): SensorStateResponse {
        const message = { key: 0, state: 0, missingState: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SensorStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorStateResponse): SensorStateResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* float state */ 2:
                    message.state = reader.float();
                    break;
                case /* bool missing_state */ 3:
                    message.missingState = reader.bool();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* float state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Bit32).float(message.state);
        /* bool missing_state = 3; */
        if (message.missingState !== false)
            writer.tag(3, WireType.Varint).bool(message.missingState);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SensorStateResponse
 */
export const SensorStateResponse = new SensorStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesSwitchResponse$Type extends MessageType<ListEntitiesSwitchResponse> {
    constructor() {
        super("ListEntitiesSwitchResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "assumed_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 9, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 17, source: "SOURCE_SERVER", ifdef: "USE_SWITCH" });
    }
    create(value?: PartialMessage<ListEntitiesSwitchResponse>): ListEntitiesSwitchResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", assumedState: false, disabledByDefault: false, entityCategory: 0, deviceClass: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesSwitchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesSwitchResponse): ListEntitiesSwitchResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool assumed_state */ 6:
                    message.assumedState = reader.bool();
                    break;
                case /* bool disabled_by_default */ 7:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 8:
                    message.entityCategory = reader.int32();
                    break;
                case /* string device_class */ 9:
                    message.deviceClass = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesSwitchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* bool assumed_state = 6; */
        if (message.assumedState !== false)
            writer.tag(6, WireType.Varint).bool(message.assumedState);
        /* bool disabled_by_default = 7; */
        if (message.disabledByDefault !== false)
            writer.tag(7, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 8; */
        if (message.entityCategory !== 0)
            writer.tag(8, WireType.Varint).int32(message.entityCategory);
        /* string device_class = 9; */
        if (message.deviceClass !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.deviceClass);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesSwitchResponse
 */
export const ListEntitiesSwitchResponse = new ListEntitiesSwitchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwitchStateResponse$Type extends MessageType<SwitchStateResponse> {
    constructor() {
        super("SwitchStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 26, source: "SOURCE_SERVER", ifdef: "USE_SWITCH", no_delay: true });
    }
    create(value?: PartialMessage<SwitchStateResponse>): SwitchStateResponse {
        const message = { key: 0, state: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SwitchStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SwitchStateResponse): SwitchStateResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SwitchStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, WireType.Varint).bool(message.state);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SwitchStateResponse
 */
export const SwitchStateResponse = new SwitchStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwitchCommandRequest$Type extends MessageType<SwitchCommandRequest> {
    constructor() {
        super("SwitchCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 33, source: "SOURCE_CLIENT", ifdef: "USE_SWITCH", no_delay: true });
    }
    create(value?: PartialMessage<SwitchCommandRequest>): SwitchCommandRequest {
        const message = { key: 0, state: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SwitchCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SwitchCommandRequest): SwitchCommandRequest {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SwitchCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, WireType.Varint).bool(message.state);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SwitchCommandRequest
 */
export const SwitchCommandRequest = new SwitchCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesTextSensorResponse$Type extends MessageType<ListEntitiesTextSensorResponse> {
    constructor() {
        super("ListEntitiesTextSensorResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 18, source: "SOURCE_SERVER", ifdef: "USE_TEXT_SENSOR" });
    }
    create(value?: PartialMessage<ListEntitiesTextSensorResponse>): ListEntitiesTextSensorResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", disabledByDefault: false, entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesTextSensorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesTextSensorResponse): ListEntitiesTextSensorResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool disabled_by_default */ 6:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesTextSensorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* bool disabled_by_default = 6; */
        if (message.disabledByDefault !== false)
            writer.tag(6, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, WireType.Varint).int32(message.entityCategory);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesTextSensorResponse
 */
export const ListEntitiesTextSensorResponse = new ListEntitiesTextSensorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TextSensorStateResponse$Type extends MessageType<TextSensorStateResponse> {
    constructor() {
        super("TextSensorStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "missing_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 27, source: "SOURCE_SERVER", ifdef: "USE_TEXT_SENSOR", no_delay: true });
    }
    create(value?: PartialMessage<TextSensorStateResponse>): TextSensorStateResponse {
        const message = { key: 0, state: "", missingState: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TextSensorStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TextSensorStateResponse): TextSensorStateResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* string state */ 2:
                    message.state = reader.string();
                    break;
                case /* bool missing_state */ 3:
                    message.missingState = reader.bool();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TextSensorStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* string state = 2; */
        if (message.state !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.state);
        /* bool missing_state = 3; */
        if (message.missingState !== false)
            writer.tag(3, WireType.Varint).bool(message.missingState);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TextSensorStateResponse
 */
export const TextSensorStateResponse = new TextSensorStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeLogsRequest$Type extends MessageType<SubscribeLogsRequest> {
    constructor() {
        super("SubscribeLogsRequest", [
            { no: 1, name: "level", kind: "enum", T: () => ["LogLevel", LogLevel, "LOG_LEVEL_"] },
            { no: 2, name: "dump_config", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 28, source: "SOURCE_CLIENT" });
    }
    create(value?: PartialMessage<SubscribeLogsRequest>): SubscribeLogsRequest {
        const message = { level: 0, dumpConfig: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeLogsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeLogsRequest): SubscribeLogsRequest {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* LogLevel level */ 1:
                    message.level = reader.int32();
                    break;
                case /* bool dump_config */ 2:
                    message.dumpConfig = reader.bool();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeLogsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* LogLevel level = 1; */
        if (message.level !== 0)
            writer.tag(1, WireType.Varint).int32(message.level);
        /* bool dump_config = 2; */
        if (message.dumpConfig !== false)
            writer.tag(2, WireType.Varint).bool(message.dumpConfig);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeLogsRequest
 */
export const SubscribeLogsRequest = new SubscribeLogsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeLogsResponse$Type extends MessageType<SubscribeLogsResponse> {
    constructor() {
        super("SubscribeLogsResponse", [
            { no: 1, name: "level", kind: "enum", T: () => ["LogLevel", LogLevel, "LOG_LEVEL_"] },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "send_failed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 29, source: "SOURCE_SERVER", log: false, no_delay: false });
    }
    create(value?: PartialMessage<SubscribeLogsResponse>): SubscribeLogsResponse {
        const message = { level: 0, message: "", sendFailed: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeLogsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeLogsResponse): SubscribeLogsResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* LogLevel level */ 1:
                    message.level = reader.int32();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* bool send_failed */ 4:
                    message.sendFailed = reader.bool();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeLogsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* LogLevel level = 1; */
        if (message.level !== 0)
            writer.tag(1, WireType.Varint).int32(message.level);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* bool send_failed = 4; */
        if (message.sendFailed !== false)
            writer.tag(4, WireType.Varint).bool(message.sendFailed);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeLogsResponse
 */
export const SubscribeLogsResponse = new SubscribeLogsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHomeassistantServicesRequest$Type extends MessageType<SubscribeHomeassistantServicesRequest> {
    constructor() {
        super("SubscribeHomeassistantServicesRequest", [], { id: 34, source: "SOURCE_CLIENT" });
    }
    create(value?: PartialMessage<SubscribeHomeassistantServicesRequest>): SubscribeHomeassistantServicesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeHomeassistantServicesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeHomeassistantServicesRequest): SubscribeHomeassistantServicesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeHomeassistantServicesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeHomeassistantServicesRequest
 */
export const SubscribeHomeassistantServicesRequest = new SubscribeHomeassistantServicesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeassistantServiceMap$Type extends MessageType<HomeassistantServiceMap> {
    constructor() {
        super("HomeassistantServiceMap", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HomeassistantServiceMap>): HomeassistantServiceMap {
        const message = { key: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeassistantServiceMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeassistantServiceMap): HomeassistantServiceMap {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeassistantServiceMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeassistantServiceMap
 */
export const HomeassistantServiceMap = new HomeassistantServiceMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeassistantServiceResponse$Type extends MessageType<HomeassistantServiceResponse> {
    constructor() {
        super("HomeassistantServiceResponse", [
            { no: 1, name: "service", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeassistantServiceMap },
            { no: 3, name: "data_template", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeassistantServiceMap },
            { no: 4, name: "variables", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeassistantServiceMap },
            { no: 5, name: "is_event", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 35, source: "SOURCE_SERVER", no_delay: true });
    }
    create(value?: PartialMessage<HomeassistantServiceResponse>): HomeassistantServiceResponse {
        const message = { service: "", data: [], dataTemplate: [], variables: [], isEvent: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeassistantServiceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeassistantServiceResponse): HomeassistantServiceResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service */ 1:
                    message.service = reader.string();
                    break;
                case /* repeated HomeassistantServiceMap data */ 2:
                    message.data.push(HomeassistantServiceMap.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated HomeassistantServiceMap data_template */ 3:
                    message.dataTemplate.push(HomeassistantServiceMap.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated HomeassistantServiceMap variables */ 4:
                    message.variables.push(HomeassistantServiceMap.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_event */ 5:
                    message.isEvent = reader.bool();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeassistantServiceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service = 1; */
        if (message.service !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.service);
        /* repeated HomeassistantServiceMap data = 2; */
        for (let i = 0; i < message.data.length; i++)
            HomeassistantServiceMap.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated HomeassistantServiceMap data_template = 3; */
        for (let i = 0; i < message.dataTemplate.length; i++)
            HomeassistantServiceMap.internalBinaryWrite(message.dataTemplate[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated HomeassistantServiceMap variables = 4; */
        for (let i = 0; i < message.variables.length; i++)
            HomeassistantServiceMap.internalBinaryWrite(message.variables[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool is_event = 5; */
        if (message.isEvent !== false)
            writer.tag(5, WireType.Varint).bool(message.isEvent);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeassistantServiceResponse
 */
export const HomeassistantServiceResponse = new HomeassistantServiceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHomeAssistantStatesRequest$Type extends MessageType<SubscribeHomeAssistantStatesRequest> {
    constructor() {
        super("SubscribeHomeAssistantStatesRequest", [], { id: 38, source: "SOURCE_CLIENT" });
    }
    create(value?: PartialMessage<SubscribeHomeAssistantStatesRequest>): SubscribeHomeAssistantStatesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeHomeAssistantStatesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeHomeAssistantStatesRequest): SubscribeHomeAssistantStatesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeHomeAssistantStatesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeHomeAssistantStatesRequest
 */
export const SubscribeHomeAssistantStatesRequest = new SubscribeHomeAssistantStatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHomeAssistantStateResponse$Type extends MessageType<SubscribeHomeAssistantStateResponse> {
    constructor() {
        super("SubscribeHomeAssistantStateResponse", [
            { no: 1, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "attribute", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 39, source: "SOURCE_SERVER" });
    }
    create(value?: PartialMessage<SubscribeHomeAssistantStateResponse>): SubscribeHomeAssistantStateResponse {
        const message = { entityId: "", attribute: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeHomeAssistantStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeHomeAssistantStateResponse): SubscribeHomeAssistantStateResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity_id */ 1:
                    message.entityId = reader.string();
                    break;
                case /* string attribute */ 2:
                    message.attribute = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeHomeAssistantStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string entity_id = 1; */
        if (message.entityId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entityId);
        /* string attribute = 2; */
        if (message.attribute !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.attribute);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeHomeAssistantStateResponse
 */
export const SubscribeHomeAssistantStateResponse = new SubscribeHomeAssistantStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeAssistantStateResponse$Type extends MessageType<HomeAssistantStateResponse> {
    constructor() {
        super("HomeAssistantStateResponse", [
            { no: 1, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "attribute", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 40, source: "SOURCE_CLIENT", no_delay: true });
    }
    create(value?: PartialMessage<HomeAssistantStateResponse>): HomeAssistantStateResponse {
        const message = { entityId: "", state: "", attribute: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeAssistantStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeAssistantStateResponse): HomeAssistantStateResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity_id */ 1:
                    message.entityId = reader.string();
                    break;
                case /* string state */ 2:
                    message.state = reader.string();
                    break;
                case /* string attribute */ 3:
                    message.attribute = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeAssistantStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string entity_id = 1; */
        if (message.entityId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entityId);
        /* string state = 2; */
        if (message.state !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.state);
        /* string attribute = 3; */
        if (message.attribute !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.attribute);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeAssistantStateResponse
 */
export const HomeAssistantStateResponse = new HomeAssistantStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTimeRequest$Type extends MessageType<GetTimeRequest> {
    constructor() {
        super("GetTimeRequest", [], { id: 36, source: "SOURCE_BOTH" });
    }
    create(value?: PartialMessage<GetTimeRequest>): GetTimeRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTimeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTimeRequest): GetTimeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetTimeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTimeRequest
 */
export const GetTimeRequest = new GetTimeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTimeResponse$Type extends MessageType<GetTimeResponse> {
    constructor() {
        super("GetTimeResponse", [
            { no: 1, name: "epoch_seconds", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ }
        ], { id: 37, source: "SOURCE_BOTH", no_delay: true });
    }
    create(value?: PartialMessage<GetTimeResponse>): GetTimeResponse {
        const message = { epochSeconds: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTimeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTimeResponse): GetTimeResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 epoch_seconds */ 1:
                    message.epochSeconds = reader.fixed32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTimeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 epoch_seconds = 1; */
        if (message.epochSeconds !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.epochSeconds);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTimeResponse
 */
export const GetTimeResponse = new GetTimeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesServicesArgument$Type extends MessageType<ListEntitiesServicesArgument> {
    constructor() {
        super("ListEntitiesServicesArgument", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["ServiceArgType", ServiceArgType, "SERVICE_ARG_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<ListEntitiesServicesArgument>): ListEntitiesServicesArgument {
        const message = { name: "", type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesServicesArgument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesServicesArgument): ListEntitiesServicesArgument {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* ServiceArgType type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesServicesArgument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* ServiceArgType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesServicesArgument
 */
export const ListEntitiesServicesArgument = new ListEntitiesServicesArgument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesServicesResponse$Type extends MessageType<ListEntitiesServicesResponse> {
    constructor() {
        super("ListEntitiesServicesResponse", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "args", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ListEntitiesServicesArgument }
        ], { id: 41, source: "SOURCE_SERVER" });
    }
    create(value?: PartialMessage<ListEntitiesServicesResponse>): ListEntitiesServicesResponse {
        const message = { name: "", key: 0, args: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesServicesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesServicesResponse): ListEntitiesServicesResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* repeated ListEntitiesServicesArgument args */ 3:
                    message.args.push(ListEntitiesServicesArgument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesServicesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* repeated ListEntitiesServicesArgument args = 3; */
        for (let i = 0; i < message.args.length; i++)
            ListEntitiesServicesArgument.internalBinaryWrite(message.args[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesServicesResponse
 */
export const ListEntitiesServicesResponse = new ListEntitiesServicesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteServiceArgument$Type extends MessageType<ExecuteServiceArgument> {
    constructor() {
        super("ExecuteServiceArgument", [
            { no: 1, name: "bool_", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "legacy_int", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "float_", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "string_", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "int_", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "bool_array", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "int_array", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 17 /*ScalarType.SINT32*/ },
            { no: 8, name: "float_array", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "string_array", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExecuteServiceArgument>): ExecuteServiceArgument {
        const message = { bool: false, legacyInt: 0, float: 0, string: "", int: 0, boolArray: [], intArray: [], floatArray: [], stringArray: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExecuteServiceArgument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteServiceArgument): ExecuteServiceArgument {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool bool_ */ 1:
                    message.bool = reader.bool();
                    break;
                case /* int32 legacy_int */ 2:
                    message.legacyInt = reader.int32();
                    break;
                case /* float float_ */ 3:
                    message.float = reader.float();
                    break;
                case /* string string_ */ 4:
                    message.string = reader.string();
                    break;
                case /* sint32 int_ */ 5:
                    message.int = reader.sint32();
                    break;
                case /* repeated bool bool_array = 6 [packed = false];*/ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.boolArray.push(reader.bool());
                    else
                        message.boolArray.push(reader.bool());
                    break;
                case /* repeated sint32 int_array = 7 [packed = false];*/ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.intArray.push(reader.sint32());
                    else
                        message.intArray.push(reader.sint32());
                    break;
                case /* repeated float float_array = 8 [packed = false];*/ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.floatArray.push(reader.float());
                    else
                        message.floatArray.push(reader.float());
                    break;
                case /* repeated string string_array */ 9:
                    message.stringArray.push(reader.string());
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteServiceArgument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool bool_ = 1; */
        if (message.bool !== false)
            writer.tag(1, WireType.Varint).bool(message.bool);
        /* int32 legacy_int = 2; */
        if (message.legacyInt !== 0)
            writer.tag(2, WireType.Varint).int32(message.legacyInt);
        /* float float_ = 3; */
        if (message.float !== 0)
            writer.tag(3, WireType.Bit32).float(message.float);
        /* string string_ = 4; */
        if (message.string !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.string);
        /* sint32 int_ = 5; */
        if (message.int !== 0)
            writer.tag(5, WireType.Varint).sint32(message.int);
        /* repeated bool bool_array = 6 [packed = false]; */
        for (let i = 0; i < message.boolArray.length; i++)
            writer.tag(6, WireType.Varint).bool(message.boolArray[i]);
        /* repeated sint32 int_array = 7 [packed = false]; */
        for (let i = 0; i < message.intArray.length; i++)
            writer.tag(7, WireType.Varint).sint32(message.intArray[i]);
        /* repeated float float_array = 8 [packed = false]; */
        for (let i = 0; i < message.floatArray.length; i++)
            writer.tag(8, WireType.Bit32).float(message.floatArray[i]);
        /* repeated string string_array = 9; */
        for (let i = 0; i < message.stringArray.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.stringArray[i]);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExecuteServiceArgument
 */
export const ExecuteServiceArgument = new ExecuteServiceArgument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteServiceRequest$Type extends MessageType<ExecuteServiceRequest> {
    constructor() {
        super("ExecuteServiceRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "args", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExecuteServiceArgument }
        ], { id: 42, source: "SOURCE_CLIENT", no_delay: true });
    }
    create(value?: PartialMessage<ExecuteServiceRequest>): ExecuteServiceRequest {
        const message = { key: 0, args: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExecuteServiceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteServiceRequest): ExecuteServiceRequest {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* repeated ExecuteServiceArgument args */ 2:
                    message.args.push(ExecuteServiceArgument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteServiceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* repeated ExecuteServiceArgument args = 2; */
        for (let i = 0; i < message.args.length; i++)
            ExecuteServiceArgument.internalBinaryWrite(message.args[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExecuteServiceRequest
 */
export const ExecuteServiceRequest = new ExecuteServiceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesCameraResponse$Type extends MessageType<ListEntitiesCameraResponse> {
    constructor() {
        super("ListEntitiesCameraResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 43, source: "SOURCE_SERVER", ifdef: "USE_ESP32_CAMERA" });
    }
    create(value?: PartialMessage<ListEntitiesCameraResponse>): ListEntitiesCameraResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", disabledByDefault: false, icon: "", entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesCameraResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesCameraResponse): ListEntitiesCameraResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* bool disabled_by_default */ 5:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 6:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesCameraResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* bool disabled_by_default = 5; */
        if (message.disabledByDefault !== false)
            writer.tag(5, WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 6; */
        if (message.icon !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, WireType.Varint).int32(message.entityCategory);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesCameraResponse
 */
export const ListEntitiesCameraResponse = new ListEntitiesCameraResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CameraImageResponse$Type extends MessageType<CameraImageResponse> {
    constructor() {
        super("CameraImageResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "done", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 44, source: "SOURCE_SERVER", ifdef: "USE_ESP32_CAMERA" });
    }
    create(value?: PartialMessage<CameraImageResponse>): CameraImageResponse {
        const message = { key: 0, data: new Uint8Array(0), done: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CameraImageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CameraImageResponse): CameraImageResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* bool done */ 3:
                    message.done = reader.bool();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CameraImageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* bool done = 3; */
        if (message.done !== false)
            writer.tag(3, WireType.Varint).bool(message.done);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CameraImageResponse
 */
export const CameraImageResponse = new CameraImageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CameraImageRequest$Type extends MessageType<CameraImageRequest> {
    constructor() {
        super("CameraImageRequest", [
            { no: 1, name: "single", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "stream", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 45, source: "SOURCE_CLIENT", ifdef: "USE_ESP32_CAMERA", no_delay: true });
    }
    create(value?: PartialMessage<CameraImageRequest>): CameraImageRequest {
        const message = { single: false, stream: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CameraImageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CameraImageRequest): CameraImageRequest {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool single */ 1:
                    message.single = reader.bool();
                    break;
                case /* bool stream */ 2:
                    message.stream = reader.bool();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CameraImageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool single = 1; */
        if (message.single !== false)
            writer.tag(1, WireType.Varint).bool(message.single);
        /* bool stream = 2; */
        if (message.stream !== false)
            writer.tag(2, WireType.Varint).bool(message.stream);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CameraImageRequest
 */
export const CameraImageRequest = new CameraImageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesClimateResponse$Type extends MessageType<ListEntitiesClimateResponse> {
    constructor() {
        super("ListEntitiesClimateResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "supports_current_temperature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "supports_two_point_target_temperature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "supported_modes", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["ClimateMode", ClimateMode, "CLIMATE_MODE_"] },
            { no: 8, name: "visual_min_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "visual_max_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "visual_temperature_step", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "legacy_supports_away", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "supports_action", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "supported_fan_modes", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["ClimateFanMode", ClimateFanMode] },
            { no: 14, name: "supported_swing_modes", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["ClimateSwingMode", ClimateSwingMode] },
            { no: 15, name: "supported_custom_fan_modes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "supported_presets", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["ClimatePreset", ClimatePreset, "CLIMATE_PRESET_"] },
            { no: 17, name: "supported_custom_presets", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 46, source: "SOURCE_SERVER", ifdef: "USE_CLIMATE" });
    }
    create(value?: PartialMessage<ListEntitiesClimateResponse>): ListEntitiesClimateResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", supportsCurrentTemperature: false, supportsTwoPointTargetTemperature: false, supportedModes: [], visualMinTemperature: 0, visualMaxTemperature: 0, visualTemperatureStep: 0, legacySupportsAway: false, supportsAction: false, supportedFanModes: [], supportedSwingModes: [], supportedCustomFanModes: [], supportedPresets: [], supportedCustomPresets: [], disabledByDefault: false, icon: "", entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesClimateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesClimateResponse): ListEntitiesClimateResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* bool supports_current_temperature */ 5:
                    message.supportsCurrentTemperature = reader.bool();
                    break;
                case /* bool supports_two_point_target_temperature */ 6:
                    message.supportsTwoPointTargetTemperature = reader.bool();
                    break;
                case /* repeated ClimateMode supported_modes */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedModes.push(reader.int32());
                    else
                        message.supportedModes.push(reader.int32());
                    break;
                case /* float visual_min_temperature */ 8:
                    message.visualMinTemperature = reader.float();
                    break;
                case /* float visual_max_temperature */ 9:
                    message.visualMaxTemperature = reader.float();
                    break;
                case /* float visual_temperature_step */ 10:
                    message.visualTemperatureStep = reader.float();
                    break;
                case /* bool legacy_supports_away */ 11:
                    message.legacySupportsAway = reader.bool();
                    break;
                case /* bool supports_action */ 12:
                    message.supportsAction = reader.bool();
                    break;
                case /* repeated ClimateFanMode supported_fan_modes */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedFanModes.push(reader.int32());
                    else
                        message.supportedFanModes.push(reader.int32());
                    break;
                case /* repeated ClimateSwingMode supported_swing_modes */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedSwingModes.push(reader.int32());
                    else
                        message.supportedSwingModes.push(reader.int32());
                    break;
                case /* repeated string supported_custom_fan_modes */ 15:
                    message.supportedCustomFanModes.push(reader.string());
                    break;
                case /* repeated ClimatePreset supported_presets */ 16:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedPresets.push(reader.int32());
                    else
                        message.supportedPresets.push(reader.int32());
                    break;
                case /* repeated string supported_custom_presets */ 17:
                    message.supportedCustomPresets.push(reader.string());
                    break;
                case /* bool disabled_by_default */ 18:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 19:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 20:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesClimateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* bool supports_current_temperature = 5; */
        if (message.supportsCurrentTemperature !== false)
            writer.tag(5, WireType.Varint).bool(message.supportsCurrentTemperature);
        /* bool supports_two_point_target_temperature = 6; */
        if (message.supportsTwoPointTargetTemperature !== false)
            writer.tag(6, WireType.Varint).bool(message.supportsTwoPointTargetTemperature);
        /* repeated ClimateMode supported_modes = 7; */
        if (message.supportedModes.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedModes.length; i++)
                writer.int32(message.supportedModes[i]);
            writer.join();
        }
        /* float visual_min_temperature = 8; */
        if (message.visualMinTemperature !== 0)
            writer.tag(8, WireType.Bit32).float(message.visualMinTemperature);
        /* float visual_max_temperature = 9; */
        if (message.visualMaxTemperature !== 0)
            writer.tag(9, WireType.Bit32).float(message.visualMaxTemperature);
        /* float visual_temperature_step = 10; */
        if (message.visualTemperatureStep !== 0)
            writer.tag(10, WireType.Bit32).float(message.visualTemperatureStep);
        /* bool legacy_supports_away = 11; */
        if (message.legacySupportsAway !== false)
            writer.tag(11, WireType.Varint).bool(message.legacySupportsAway);
        /* bool supports_action = 12; */
        if (message.supportsAction !== false)
            writer.tag(12, WireType.Varint).bool(message.supportsAction);
        /* repeated ClimateFanMode supported_fan_modes = 13; */
        if (message.supportedFanModes.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedFanModes.length; i++)
                writer.int32(message.supportedFanModes[i]);
            writer.join();
        }
        /* repeated ClimateSwingMode supported_swing_modes = 14; */
        if (message.supportedSwingModes.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedSwingModes.length; i++)
                writer.int32(message.supportedSwingModes[i]);
            writer.join();
        }
        /* repeated string supported_custom_fan_modes = 15; */
        for (let i = 0; i < message.supportedCustomFanModes.length; i++)
            writer.tag(15, WireType.LengthDelimited).string(message.supportedCustomFanModes[i]);
        /* repeated ClimatePreset supported_presets = 16; */
        if (message.supportedPresets.length) {
            writer.tag(16, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedPresets.length; i++)
                writer.int32(message.supportedPresets[i]);
            writer.join();
        }
        /* repeated string supported_custom_presets = 17; */
        for (let i = 0; i < message.supportedCustomPresets.length; i++)
            writer.tag(17, WireType.LengthDelimited).string(message.supportedCustomPresets[i]);
        /* bool disabled_by_default = 18; */
        if (message.disabledByDefault !== false)
            writer.tag(18, WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 19; */
        if (message.icon !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 20; */
        if (message.entityCategory !== 0)
            writer.tag(20, WireType.Varint).int32(message.entityCategory);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesClimateResponse
 */
export const ListEntitiesClimateResponse = new ListEntitiesClimateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClimateStateResponse$Type extends MessageType<ClimateStateResponse> {
    constructor() {
        super("ClimateStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "mode", kind: "enum", T: () => ["ClimateMode", ClimateMode, "CLIMATE_MODE_"] },
            { no: 3, name: "current_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "target_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "target_temperature_low", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "target_temperature_high", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "legacy_away", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "action", kind: "enum", T: () => ["ClimateAction", ClimateAction, "CLIMATE_ACTION_"] },
            { no: 9, name: "fan_mode", kind: "enum", T: () => ["ClimateFanMode", ClimateFanMode] },
            { no: 10, name: "swing_mode", kind: "enum", T: () => ["ClimateSwingMode", ClimateSwingMode] },
            { no: 11, name: "custom_fan_mode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "preset", kind: "enum", T: () => ["ClimatePreset", ClimatePreset, "CLIMATE_PRESET_"] },
            { no: 13, name: "custom_preset", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 47, source: "SOURCE_SERVER", ifdef: "USE_CLIMATE", no_delay: true });
    }
    create(value?: PartialMessage<ClimateStateResponse>): ClimateStateResponse {
        const message = { key: 0, mode: 0, currentTemperature: 0, targetTemperature: 0, targetTemperatureLow: 0, targetTemperatureHigh: 0, legacyAway: false, action: 0, fanMode: 0, swingMode: 0, customFanMode: "", preset: 0, customPreset: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClimateStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClimateStateResponse): ClimateStateResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* ClimateMode mode */ 2:
                    message.mode = reader.int32();
                    break;
                case /* float current_temperature */ 3:
                    message.currentTemperature = reader.float();
                    break;
                case /* float target_temperature */ 4:
                    message.targetTemperature = reader.float();
                    break;
                case /* float target_temperature_low */ 5:
                    message.targetTemperatureLow = reader.float();
                    break;
                case /* float target_temperature_high */ 6:
                    message.targetTemperatureHigh = reader.float();
                    break;
                case /* bool legacy_away */ 7:
                    message.legacyAway = reader.bool();
                    break;
                case /* ClimateAction action */ 8:
                    message.action = reader.int32();
                    break;
                case /* ClimateFanMode fan_mode */ 9:
                    message.fanMode = reader.int32();
                    break;
                case /* ClimateSwingMode swing_mode */ 10:
                    message.swingMode = reader.int32();
                    break;
                case /* string custom_fan_mode */ 11:
                    message.customFanMode = reader.string();
                    break;
                case /* ClimatePreset preset */ 12:
                    message.preset = reader.int32();
                    break;
                case /* string custom_preset */ 13:
                    message.customPreset = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClimateStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* ClimateMode mode = 2; */
        if (message.mode !== 0)
            writer.tag(2, WireType.Varint).int32(message.mode);
        /* float current_temperature = 3; */
        if (message.currentTemperature !== 0)
            writer.tag(3, WireType.Bit32).float(message.currentTemperature);
        /* float target_temperature = 4; */
        if (message.targetTemperature !== 0)
            writer.tag(4, WireType.Bit32).float(message.targetTemperature);
        /* float target_temperature_low = 5; */
        if (message.targetTemperatureLow !== 0)
            writer.tag(5, WireType.Bit32).float(message.targetTemperatureLow);
        /* float target_temperature_high = 6; */
        if (message.targetTemperatureHigh !== 0)
            writer.tag(6, WireType.Bit32).float(message.targetTemperatureHigh);
        /* bool legacy_away = 7; */
        if (message.legacyAway !== false)
            writer.tag(7, WireType.Varint).bool(message.legacyAway);
        /* ClimateAction action = 8; */
        if (message.action !== 0)
            writer.tag(8, WireType.Varint).int32(message.action);
        /* ClimateFanMode fan_mode = 9; */
        if (message.fanMode !== 0)
            writer.tag(9, WireType.Varint).int32(message.fanMode);
        /* ClimateSwingMode swing_mode = 10; */
        if (message.swingMode !== 0)
            writer.tag(10, WireType.Varint).int32(message.swingMode);
        /* string custom_fan_mode = 11; */
        if (message.customFanMode !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.customFanMode);
        /* ClimatePreset preset = 12; */
        if (message.preset !== 0)
            writer.tag(12, WireType.Varint).int32(message.preset);
        /* string custom_preset = 13; */
        if (message.customPreset !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.customPreset);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ClimateStateResponse
 */
export const ClimateStateResponse = new ClimateStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClimateCommandRequest$Type extends MessageType<ClimateCommandRequest> {
    constructor() {
        super("ClimateCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "mode", kind: "enum", T: () => ["ClimateMode", ClimateMode, "CLIMATE_MODE_"] },
            { no: 4, name: "has_target_temperature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "target_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "has_target_temperature_low", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "target_temperature_low", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "has_target_temperature_high", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "target_temperature_high", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "has_legacy_away", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "legacy_away", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "has_fan_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "fan_mode", kind: "enum", T: () => ["ClimateFanMode", ClimateFanMode] },
            { no: 14, name: "has_swing_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "swing_mode", kind: "enum", T: () => ["ClimateSwingMode", ClimateSwingMode] },
            { no: 16, name: "has_custom_fan_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "custom_fan_mode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "has_preset", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "preset", kind: "enum", T: () => ["ClimatePreset", ClimatePreset, "CLIMATE_PRESET_"] },
            { no: 20, name: "has_custom_preset", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "custom_preset", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 48, source: "SOURCE_CLIENT", ifdef: "USE_CLIMATE", no_delay: true });
    }
    create(value?: PartialMessage<ClimateCommandRequest>): ClimateCommandRequest {
        const message = { key: 0, hasMode: false, mode: 0, hasTargetTemperature: false, targetTemperature: 0, hasTargetTemperatureLow: false, targetTemperatureLow: 0, hasTargetTemperatureHigh: false, targetTemperatureHigh: 0, hasLegacyAway: false, legacyAway: false, hasFanMode: false, fanMode: 0, hasSwingMode: false, swingMode: 0, hasCustomFanMode: false, customFanMode: "", hasPreset: false, preset: 0, hasCustomPreset: false, customPreset: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClimateCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClimateCommandRequest): ClimateCommandRequest {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_mode */ 2:
                    message.hasMode = reader.bool();
                    break;
                case /* ClimateMode mode */ 3:
                    message.mode = reader.int32();
                    break;
                case /* bool has_target_temperature */ 4:
                    message.hasTargetTemperature = reader.bool();
                    break;
                case /* float target_temperature */ 5:
                    message.targetTemperature = reader.float();
                    break;
                case /* bool has_target_temperature_low */ 6:
                    message.hasTargetTemperatureLow = reader.bool();
                    break;
                case /* float target_temperature_low */ 7:
                    message.targetTemperatureLow = reader.float();
                    break;
                case /* bool has_target_temperature_high */ 8:
                    message.hasTargetTemperatureHigh = reader.bool();
                    break;
                case /* float target_temperature_high */ 9:
                    message.targetTemperatureHigh = reader.float();
                    break;
                case /* bool has_legacy_away */ 10:
                    message.hasLegacyAway = reader.bool();
                    break;
                case /* bool legacy_away */ 11:
                    message.legacyAway = reader.bool();
                    break;
                case /* bool has_fan_mode */ 12:
                    message.hasFanMode = reader.bool();
                    break;
                case /* ClimateFanMode fan_mode */ 13:
                    message.fanMode = reader.int32();
                    break;
                case /* bool has_swing_mode */ 14:
                    message.hasSwingMode = reader.bool();
                    break;
                case /* ClimateSwingMode swing_mode */ 15:
                    message.swingMode = reader.int32();
                    break;
                case /* bool has_custom_fan_mode */ 16:
                    message.hasCustomFanMode = reader.bool();
                    break;
                case /* string custom_fan_mode */ 17:
                    message.customFanMode = reader.string();
                    break;
                case /* bool has_preset */ 18:
                    message.hasPreset = reader.bool();
                    break;
                case /* ClimatePreset preset */ 19:
                    message.preset = reader.int32();
                    break;
                case /* bool has_custom_preset */ 20:
                    message.hasCustomPreset = reader.bool();
                    break;
                case /* string custom_preset */ 21:
                    message.customPreset = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClimateCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool has_mode = 2; */
        if (message.hasMode !== false)
            writer.tag(2, WireType.Varint).bool(message.hasMode);
        /* ClimateMode mode = 3; */
        if (message.mode !== 0)
            writer.tag(3, WireType.Varint).int32(message.mode);
        /* bool has_target_temperature = 4; */
        if (message.hasTargetTemperature !== false)
            writer.tag(4, WireType.Varint).bool(message.hasTargetTemperature);
        /* float target_temperature = 5; */
        if (message.targetTemperature !== 0)
            writer.tag(5, WireType.Bit32).float(message.targetTemperature);
        /* bool has_target_temperature_low = 6; */
        if (message.hasTargetTemperatureLow !== false)
            writer.tag(6, WireType.Varint).bool(message.hasTargetTemperatureLow);
        /* float target_temperature_low = 7; */
        if (message.targetTemperatureLow !== 0)
            writer.tag(7, WireType.Bit32).float(message.targetTemperatureLow);
        /* bool has_target_temperature_high = 8; */
        if (message.hasTargetTemperatureHigh !== false)
            writer.tag(8, WireType.Varint).bool(message.hasTargetTemperatureHigh);
        /* float target_temperature_high = 9; */
        if (message.targetTemperatureHigh !== 0)
            writer.tag(9, WireType.Bit32).float(message.targetTemperatureHigh);
        /* bool has_legacy_away = 10; */
        if (message.hasLegacyAway !== false)
            writer.tag(10, WireType.Varint).bool(message.hasLegacyAway);
        /* bool legacy_away = 11; */
        if (message.legacyAway !== false)
            writer.tag(11, WireType.Varint).bool(message.legacyAway);
        /* bool has_fan_mode = 12; */
        if (message.hasFanMode !== false)
            writer.tag(12, WireType.Varint).bool(message.hasFanMode);
        /* ClimateFanMode fan_mode = 13; */
        if (message.fanMode !== 0)
            writer.tag(13, WireType.Varint).int32(message.fanMode);
        /* bool has_swing_mode = 14; */
        if (message.hasSwingMode !== false)
            writer.tag(14, WireType.Varint).bool(message.hasSwingMode);
        /* ClimateSwingMode swing_mode = 15; */
        if (message.swingMode !== 0)
            writer.tag(15, WireType.Varint).int32(message.swingMode);
        /* bool has_custom_fan_mode = 16; */
        if (message.hasCustomFanMode !== false)
            writer.tag(16, WireType.Varint).bool(message.hasCustomFanMode);
        /* string custom_fan_mode = 17; */
        if (message.customFanMode !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.customFanMode);
        /* bool has_preset = 18; */
        if (message.hasPreset !== false)
            writer.tag(18, WireType.Varint).bool(message.hasPreset);
        /* ClimatePreset preset = 19; */
        if (message.preset !== 0)
            writer.tag(19, WireType.Varint).int32(message.preset);
        /* bool has_custom_preset = 20; */
        if (message.hasCustomPreset !== false)
            writer.tag(20, WireType.Varint).bool(message.hasCustomPreset);
        /* string custom_preset = 21; */
        if (message.customPreset !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.customPreset);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ClimateCommandRequest
 */
export const ClimateCommandRequest = new ClimateCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesNumberResponse$Type extends MessageType<ListEntitiesNumberResponse> {
    constructor() {
        super("ListEntitiesNumberResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "min_value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "max_value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "step", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 11, name: "unit_of_measurement", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "mode", kind: "enum", T: () => ["NumberMode", NumberMode, "NUMBER_MODE_"] }
        ], { id: 49, source: "SOURCE_SERVER", ifdef: "USE_NUMBER" });
    }
    create(value?: PartialMessage<ListEntitiesNumberResponse>): ListEntitiesNumberResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", minValue: 0, maxValue: 0, step: 0, disabledByDefault: false, entityCategory: 0, unitOfMeasurement: "", mode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesNumberResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesNumberResponse): ListEntitiesNumberResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* float min_value */ 6:
                    message.minValue = reader.float();
                    break;
                case /* float max_value */ 7:
                    message.maxValue = reader.float();
                    break;
                case /* float step */ 8:
                    message.step = reader.float();
                    break;
                case /* bool disabled_by_default */ 9:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 10:
                    message.entityCategory = reader.int32();
                    break;
                case /* string unit_of_measurement */ 11:
                    message.unitOfMeasurement = reader.string();
                    break;
                case /* NumberMode mode */ 12:
                    message.mode = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesNumberResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* float min_value = 6; */
        if (message.minValue !== 0)
            writer.tag(6, WireType.Bit32).float(message.minValue);
        /* float max_value = 7; */
        if (message.maxValue !== 0)
            writer.tag(7, WireType.Bit32).float(message.maxValue);
        /* float step = 8; */
        if (message.step !== 0)
            writer.tag(8, WireType.Bit32).float(message.step);
        /* bool disabled_by_default = 9; */
        if (message.disabledByDefault !== false)
            writer.tag(9, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 10; */
        if (message.entityCategory !== 0)
            writer.tag(10, WireType.Varint).int32(message.entityCategory);
        /* string unit_of_measurement = 11; */
        if (message.unitOfMeasurement !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.unitOfMeasurement);
        /* NumberMode mode = 12; */
        if (message.mode !== 0)
            writer.tag(12, WireType.Varint).int32(message.mode);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesNumberResponse
 */
export const ListEntitiesNumberResponse = new ListEntitiesNumberResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NumberStateResponse$Type extends MessageType<NumberStateResponse> {
    constructor() {
        super("NumberStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "missing_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 50, source: "SOURCE_SERVER", ifdef: "USE_NUMBER", no_delay: true });
    }
    create(value?: PartialMessage<NumberStateResponse>): NumberStateResponse {
        const message = { key: 0, state: 0, missingState: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NumberStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NumberStateResponse): NumberStateResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* float state */ 2:
                    message.state = reader.float();
                    break;
                case /* bool missing_state */ 3:
                    message.missingState = reader.bool();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NumberStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* float state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Bit32).float(message.state);
        /* bool missing_state = 3; */
        if (message.missingState !== false)
            writer.tag(3, WireType.Varint).bool(message.missingState);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NumberStateResponse
 */
export const NumberStateResponse = new NumberStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NumberCommandRequest$Type extends MessageType<NumberCommandRequest> {
    constructor() {
        super("NumberCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ], { id: 51, source: "SOURCE_CLIENT", ifdef: "USE_NUMBER", no_delay: true });
    }
    create(value?: PartialMessage<NumberCommandRequest>): NumberCommandRequest {
        const message = { key: 0, state: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NumberCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NumberCommandRequest): NumberCommandRequest {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* float state */ 2:
                    message.state = reader.float();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NumberCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* float state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Bit32).float(message.state);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NumberCommandRequest
 */
export const NumberCommandRequest = new NumberCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesSelectResponse$Type extends MessageType<ListEntitiesSelectResponse> {
    constructor() {
        super("ListEntitiesSelectResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "options", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 52, source: "SOURCE_SERVER", ifdef: "USE_SELECT" });
    }
    create(value?: PartialMessage<ListEntitiesSelectResponse>): ListEntitiesSelectResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", options: [], disabledByDefault: false, entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesSelectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesSelectResponse): ListEntitiesSelectResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* repeated string options */ 6:
                    message.options.push(reader.string());
                    break;
                case /* bool disabled_by_default */ 7:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 8:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesSelectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* repeated string options = 6; */
        for (let i = 0; i < message.options.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.options[i]);
        /* bool disabled_by_default = 7; */
        if (message.disabledByDefault !== false)
            writer.tag(7, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 8; */
        if (message.entityCategory !== 0)
            writer.tag(8, WireType.Varint).int32(message.entityCategory);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesSelectResponse
 */
export const ListEntitiesSelectResponse = new ListEntitiesSelectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectStateResponse$Type extends MessageType<SelectStateResponse> {
    constructor() {
        super("SelectStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "missing_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 53, source: "SOURCE_SERVER", ifdef: "USE_SELECT", no_delay: true });
    }
    create(value?: PartialMessage<SelectStateResponse>): SelectStateResponse {
        const message = { key: 0, state: "", missingState: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelectStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelectStateResponse): SelectStateResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* string state */ 2:
                    message.state = reader.string();
                    break;
                case /* bool missing_state */ 3:
                    message.missingState = reader.bool();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelectStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* string state = 2; */
        if (message.state !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.state);
        /* bool missing_state = 3; */
        if (message.missingState !== false)
            writer.tag(3, WireType.Varint).bool(message.missingState);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SelectStateResponse
 */
export const SelectStateResponse = new SelectStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectCommandRequest$Type extends MessageType<SelectCommandRequest> {
    constructor() {
        super("SelectCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 54, source: "SOURCE_CLIENT", ifdef: "USE_SELECT", no_delay: true });
    }
    create(value?: PartialMessage<SelectCommandRequest>): SelectCommandRequest {
        const message = { key: 0, state: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelectCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelectCommandRequest): SelectCommandRequest {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* string state */ 2:
                    message.state = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelectCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* string state = 2; */
        if (message.state !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.state);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SelectCommandRequest
 */
export const SelectCommandRequest = new SelectCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesLockResponse$Type extends MessageType<ListEntitiesLockResponse> {
    constructor() {
        super("ListEntitiesLockResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 8, name: "assumed_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "supports_open", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "requires_code", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "code_format", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 58, source: "SOURCE_SERVER", ifdef: "USE_LOCK" });
    }
    create(value?: PartialMessage<ListEntitiesLockResponse>): ListEntitiesLockResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", disabledByDefault: false, entityCategory: 0, assumedState: false, supportsOpen: false, requiresCode: false, codeFormat: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesLockResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesLockResponse): ListEntitiesLockResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool disabled_by_default */ 6:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                case /* bool assumed_state */ 8:
                    message.assumedState = reader.bool();
                    break;
                case /* bool supports_open */ 9:
                    message.supportsOpen = reader.bool();
                    break;
                case /* bool requires_code */ 10:
                    message.requiresCode = reader.bool();
                    break;
                case /* string code_format */ 11:
                    message.codeFormat = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesLockResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* bool disabled_by_default = 6; */
        if (message.disabledByDefault !== false)
            writer.tag(6, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, WireType.Varint).int32(message.entityCategory);
        /* bool assumed_state = 8; */
        if (message.assumedState !== false)
            writer.tag(8, WireType.Varint).bool(message.assumedState);
        /* bool supports_open = 9; */
        if (message.supportsOpen !== false)
            writer.tag(9, WireType.Varint).bool(message.supportsOpen);
        /* bool requires_code = 10; */
        if (message.requiresCode !== false)
            writer.tag(10, WireType.Varint).bool(message.requiresCode);
        /* string code_format = 11; */
        if (message.codeFormat !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.codeFormat);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesLockResponse
 */
export const ListEntitiesLockResponse = new ListEntitiesLockResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockStateResponse$Type extends MessageType<LockStateResponse> {
    constructor() {
        super("LockStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["LockState", LockState, "LOCK_STATE_"] }
        ], { id: 59, source: "SOURCE_SERVER", ifdef: "USE_LOCK", no_delay: true });
    }
    create(value?: PartialMessage<LockStateResponse>): LockStateResponse {
        const message = { key: 0, state: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LockStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockStateResponse): LockStateResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* LockState state */ 2:
                    message.state = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* LockState state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).int32(message.state);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LockStateResponse
 */
export const LockStateResponse = new LockStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockCommandRequest$Type extends MessageType<LockCommandRequest> {
    constructor() {
        super("LockCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "command", kind: "enum", T: () => ["LockCommand", LockCommand] },
            { no: 3, name: "has_code", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 60, source: "SOURCE_CLIENT", ifdef: "USE_LOCK", no_delay: true });
    }
    create(value?: PartialMessage<LockCommandRequest>): LockCommandRequest {
        const message = { key: 0, command: 0, hasCode: false, code: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LockCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockCommandRequest): LockCommandRequest {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* LockCommand command */ 2:
                    message.command = reader.int32();
                    break;
                case /* bool has_code */ 3:
                    message.hasCode = reader.bool();
                    break;
                case /* string code */ 4:
                    message.code = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* LockCommand command = 2; */
        if (message.command !== 0)
            writer.tag(2, WireType.Varint).int32(message.command);
        /* bool has_code = 3; */
        if (message.hasCode !== false)
            writer.tag(3, WireType.Varint).bool(message.hasCode);
        /* string code = 4; */
        if (message.code !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.code);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LockCommandRequest
 */
export const LockCommandRequest = new LockCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesButtonResponse$Type extends MessageType<ListEntitiesButtonResponse> {
    constructor() {
        super("ListEntitiesButtonResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 8, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 61, source: "SOURCE_SERVER", ifdef: "USE_BUTTON" });
    }
    create(value?: PartialMessage<ListEntitiesButtonResponse>): ListEntitiesButtonResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", disabledByDefault: false, entityCategory: 0, deviceClass: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesButtonResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesButtonResponse): ListEntitiesButtonResponse {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool disabled_by_default */ 6:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                case /* string device_class */ 8:
                    message.deviceClass = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesButtonResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* bool disabled_by_default = 6; */
        if (message.disabledByDefault !== false)
            writer.tag(6, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, WireType.Varint).int32(message.entityCategory);
        /* string device_class = 8; */
        if (message.deviceClass !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.deviceClass);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesButtonResponse
 */
export const ListEntitiesButtonResponse = new ListEntitiesButtonResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ButtonCommandRequest$Type extends MessageType<ButtonCommandRequest> {
    constructor() {
        super("ButtonCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ }
        ], { id: 62, source: "SOURCE_CLIENT", ifdef: "USE_BUTTON", no_delay: true });
    }
    create(value?: PartialMessage<ButtonCommandRequest>): ButtonCommandRequest {
        const message = { key: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ButtonCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ButtonCommandRequest): ButtonCommandRequest {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ButtonCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ButtonCommandRequest
 */
export const ButtonCommandRequest = new ButtonCommandRequest$Type();
/**
 * @generated ServiceType for protobuf service APIConnection
 */
export const APIConnection = new ServiceType("APIConnection", [
    { name: "hello", options: { needs_setup_connection: false, needs_authentication: false }, I: HelloRequest, O: HelloResponse },
    { name: "connect", options: { needs_setup_connection: false, needs_authentication: false }, I: ConnectRequest, O: ConnectResponse },
    { name: "disconnect", options: { needs_setup_connection: false, needs_authentication: false }, I: DisconnectRequest, O: DisconnectResponse },
    { name: "ping", options: { needs_setup_connection: false, needs_authentication: false }, I: PingRequest, O: PingResponse },
    { name: "device_info", options: { needs_authentication: false }, I: DeviceInfoRequest, O: DeviceInfoResponse },
    { name: "list_entities", options: {}, I: ListEntitiesRequest, O: void$ },
    { name: "subscribe_states", options: {}, I: SubscribeStatesRequest, O: void$ },
    { name: "subscribe_logs", options: {}, I: SubscribeLogsRequest, O: void$ },
    { name: "subscribe_homeassistant_services", options: {}, I: SubscribeHomeassistantServicesRequest, O: void$ },
    { name: "subscribe_home_assistant_states", options: {}, I: SubscribeHomeAssistantStatesRequest, O: void$ },
    { name: "get_time", options: { needs_authentication: false }, I: GetTimeRequest, O: GetTimeResponse },
    { name: "execute_service", options: {}, I: ExecuteServiceRequest, O: void$ },
    { name: "cover_command", options: {}, I: CoverCommandRequest, O: void$ },
    { name: "fan_command", options: {}, I: FanCommandRequest, O: void$ },
    { name: "light_command", options: {}, I: LightCommandRequest, O: void$ },
    { name: "switch_command", options: {}, I: SwitchCommandRequest, O: void$ },
    { name: "camera_image", options: {}, I: CameraImageRequest, O: void$ },
    { name: "climate_command", options: {}, I: ClimateCommandRequest, O: void$ },
    { name: "number_command", options: {}, I: NumberCommandRequest, O: void$ },
    { name: "select_command", options: {}, I: SelectCommandRequest, O: void$ },
    { name: "button_command", options: {}, I: ButtonCommandRequest, O: void$ },
    { name: "lock_command", options: {}, I: LockCommandRequest, O: void$ }
]);
